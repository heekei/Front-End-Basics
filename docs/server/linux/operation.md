# Linux 服务器运维

## 性能相关

### 查看使用内存最多的 10 个进程

```bash

ps aux | sort -nrk 4 | head -10

```

### 查看使用 CPU 最多的 10 个进程

```bash

ps aux | sort -nrk 3 | head -10

```

### 查看硬盘空间

#### 检查磁盘使用情况

```bash
df -h
```

这个命令会显示所有文件系统的使用情况。

#### 查找占用空间最大的目录

```bash
# 要注意权限问题，而且会查询的很慢
du -h --max-depth=1 / | sort -h
```

从根目录开始，查找哪个一级目录占用最多空间。可以逐层深入，例如：

```bash
du -h --max-depth=1 /var | sort -h
```

## 服务相关

### systemctl 命令

```sh
#开机运行服务
systemctl enable *.service
#取消开机运行
systemctl disable *.service
#启动服务
systemctl start *.service
#停止服务
systemctl stop *.service
#重启服务
systemctl restart *.service
#重新加载服务配置文件
systemctl reload *.service
#查询服务运行状态
systemctl status *.service
#显示启动失败的服务
systemctl --failed
```

### which 命令

用于查找某个命令的绝对路径

```sh
which rm
# /usr/bin/rm
which ls
#ls='ls --color=tty'
#/usr/bin/ls
```

## 用户相关

### 查看登录的用户

```sh
# 查看登录的用户列表
who

# 查看登录的用户列表的详细信息
w

# 查看登录的当前用户
whoami

# 查看登录的当前用户的详细信息
who am i
# 或
w $USER
```

### 创建用户和更改用户权限概览

```sh
# 创建一个文件夹，查看当前用户拥有的文件夹权限
mkdir demo && ls -l demo
# drwxrwxr-x 2 root root 4096 Jan 14 11:48 demo

sudo useradd ceshi # 创建一个新用户
sudo passwd ceshi # 设置用户密码
su ceshi # 切换 ceshi 用户登录
cd demo # 进入 demo 文件夹
touch index.js # 创建 index.js 文件，提示无权限

# chown chmod chgrp
sudo chown -R ceshi:ceshi ./demo # demo 文件夹的所有者改成 ceshi
su ceshi # 切换 ceshi 用户
touch index.js # 创建 index.js 文件成功
```

### 创建、删除用户，修改用户组、家目录

```sh
# 创建用户 newuser
sudo useradd newuser
# 设置 newuser 用户密码
sudo passwd newuser
# 修改用户密码最大过期时间
sudo chage -M 90 newuser #sudo chage -M [最大天数] [用户名]
# 修改用户信息
# 修改用户名 olduser 修改为 newuser
sudo usermod -l newuser olduser # sudo usermod -l [新用户名] [旧用户名]
# 修改用户 newuser 的用户目录为 /home/newdir
sudo usermod -d /home/newdir newuser
# 修改用户 newuser 的所在组为 newgroup
sudo usermod -g newgroup newuser
# -a 参数表示附加，只和 -G 参数一同使用，表示在添加用户到新组的同时保持其在其他组的成员资格
# wheel 组的成员可以使用 sudo 命令执行需要 root 权限的命令。
sudo usermod -aG whell newuser
# 删除 newuser 用户
sudo userdel newuser
# 列出 newuser 用户的详细信息，包括登录信息，家目录
finger newuser
```

### /etc/passwd

#### 查看用户列表、修改用户默认 shell、切换用户

```sh
# 查看所有用户列表
cat /etc/passwd
# 修改用户的默认 shell
chsh -s /bin/bash newuser


# 切换用户
su - newuser
# 切换系统管理员执行命令
su
su -root
# 使用 sudo 命令也可以实现
```

`/etc/passwd` 文件中的每一行都代表一个用户的记录，记录中包含了该用户的基本信息，每条记录由七个字段组成，字段之间使用冒号（:）分隔。这些字段的含义依次是：

1. **用户名**：用户的登录名。
2. **密码**：存放加密后的用户密码。现在大多数 Linux 系统中，这个字段已经不再存放真正的密码，通常会被 x 或者 \* 取代，而真正的加密密码会存放在 `/etc/shadow` 文件中。
3. **用户 ID**：用户的数字标识符 (UID)。
4. **组 ID**：用户的初始组标识符 (GID)。
5. **用户描述**：用户的详细说明或注释信息。
6. **家目录**：用户的家目录，即用户登录后默认所在的目录。
7. **登录 shell**：用户登录系统后使用的默认 shell。

例如，`/etc/passwd` 文件中的一条记录可能如下所示：

```
john:x:1001:1001:John Smith:/home/john:/bin/bash
```

在这个例子中：

- 用户名为 `john`
- 密码字段被替换为 `x`，真正的密码存放在 `/etc/shadow` 文件中
- 用户 ID 为 `1001`
- 初始组 ID 为 `1001`
- 用户描述为 `John Smith`
- 家目录为 `/home/john`
- 登录 shell 为 `/bin/bash`

### /etc/group

#### 概览

```sh
# 创建用户组
sudo groupadd newgroup
# 修改组名称
groupmod -n newgroup oldgroup
# 删除 oldgroup 用户组
sudo groupdel oldgroup
# 列出用户 newuser 的所在组
groups newuser
# 查看系统中所有的用户组
cat /etc/group
```

您可以使用以下命令来查看系统中所有的用户组：

```bash
cat /etc/group
```

这条命令会显示 `/etc/group` 文件中的内容，其中包含了系统中所有用户组的信息。当您执行这条命令时，会列出每个用户组的记录，每个记录由四个字段组成，字段之间使用冒号（:）进行分隔。这些字段的含义依次是：

1. 用户组名
2. 密码占位符（通常为空，真正的密码存放在 `/etc/gshadow` 文件中）
3. 用户组 ID
4. 该用户组包含的用户列表

#### `groupmod` 命令

`groupmod` 命令用于修改已存在的组的属性。以下是 `groupmod` 命令的基本用法和选项：

```bash
groupmod [options] GROUP
```

选项包括：

- `-g GID`：修改组的 GID（组标识符）。
- `-n NEW_GROUP`：修改组的名称为 NEW_GROUP。

例如，要将名为 `oldgroup` 的组的名称修改为 `newgroup`，可以使用以下命令：

```bash
groupmod -n newgroup oldgroup
```

要将名为 `mygroup` 的组的 GID 修改为 `1500`，可以使用以下命令：

```bash
groupmod -g 1500 mygroup
```

请注意，修改组属性可能会影响系统上与该组相关联的文件和权限。在进行这些修改时，请务必小心谨慎。

#### `gpasswd` 命令

`gpasswd` 命令用于管理组的密码和组成员。以下是 `gpasswd` 命令的基本用法和选项：

```bash
gpasswd [options] group
```

选项：

- `-a user`：将用户添加到组中。
- `-d user`：将用户从组中删除。
- `-A user`：指定一个管理员用户，只有管理员用户可以修改组成员。
- `-M user_list`：设置组的成员列表。
- `-r`：删除组的密码。
- `-R`：启用或禁用只读组成员列表。

## 文件管理

### mkdir 命令

```sh
# -p 可以创建多级目录，可以创建已存在的目录不报错
mkdir -p demo/demo1/demo2
```

### `ls` 和 `ll` 命令

`ls` 和 `ll` 都是用于列出文件和目录的命令，通常用于查看当前工作目录中的内容。这两个命令在大多数 Linux 和 Unix 系统中都是常用的。

- `ls`：`ls` 命令用于列出指定目录中的文件和子目录。其基本用法如下：

  ```
  ls [选项] [文件或目录]
  ```

  一些常用的选项包括：

  - `-l`：以长格式显示文件和目录的详细信息，包括权限、所有者、大小、修改日期等。
  - `-a`：显示所有文件，包括以"."开头的隐藏文件。
  - `-d`：表示列出目录本身的信息，而不是列出目录中的内容。这意味着它会显示指定目录的详细信息，而不会列出该目录中的文件和子目录。
  - `-h`：以人类可读的格式显示文件大小，例如 KB、MB 等。
  - `-r`：反向排序，按字母逆序显示文件和目录。
  - `-t`：按修改时间顺序显示文件和目录。

  例如，要显示当前目录下所有文件和目录的详细信息，您可以使用以下命令：

  ```
  ls -l
  ```

- `ll`：`ll` 实际上是 `ls -l` 的一个别名，它会以长格式显示当前目录中的文件和子目录的详细信息。

### `chown` 命令

`chown` 命令用于更改文件或目录的所有者。它是"change owner"的缩写。`chown` 命令的详细用法如下：

```
chown [新所有者][:新用户组] 文件名
```

- **新所有者**：指定新的所有者用户名或用户 ID。
- **新用户组**：可选，指定新的用户组名称或用户组 ID。如果省略，则文件的用户组将不会更改。

一些常用的选项包括：

- `-R`：递归地更改指定目录及其子目录中的所有文件和目录的所有者。
- `--from=当前所有者[:当前用户组]`：仅在当前所有者匹配给定的所有者和用户组时才更改文件的所有者。
- `--reference=参考文件或目录`：将指定文件或目录的所有者和用户组设置为参考文件或目录的所有者和用户组。

例如，要将文件 `file.txt` 的所有者更改为 `newuser`，并将用户组更改为 `newgroup`，您可以使用以下命令：

```
chown newuser:newgroup file.txt
```

要递归地更改目录 `mydir` 及其所有子目录和文件的所有者为 `newuser`，您可以使用以下命令：

```
chown -R newuser mydir
```

### `chmod` 命令

chmod 命令用于修改文件或目录的权限。当使用 `chmod` 命令时，可以使用两种不同的方式来指定文件权限：数字表示法和符号表示法。以下是详细的说明和示例：

#### 数字表示法

数字表示法使用三个八进制数字来表示文件权限，每个数字代表一组权限（所有者、所属用户组、其他用户）。每个数字由 0 到 7 组成，分别代表不同的权限组合。

- `4` 表示读权限（r）
- `2` 表示写权限（w）
- `1` 表示执行权限（x）

要设置文件权限，您可以使用以下命令格式：

```
chmod [mode] file
```

其中，`mode` 由三个数字组成，分别表示所有者、所属用户组、其他用户的权限。例如，要将文件 `file.txt` 的权限设置为 `-rwxr-xr--`，可以使用以下命令：

```
chmod 754 file.txt
```

这将为文件的所有者设置读、写、执行权限，为所属用户组设置读、执行权限，为其他用户设置只读权限。

### 符号表示法

符号表示法使用字母和符号来表示文件权限，相对更易读和灵活。以下是符号表示法中常用的符号和字母：

- `u`：代表文件所有者
- `g`：代表所属用户组
- `o`：代表其他用户
- `+`：添加权限
- `-`：移除权限
- `=`：设置权限

要使用符号表示法设置文件权限，可以使用以下命令格式：

```
chmod [who][operator][permissions] file
```

其中，`who` 是指定权限变更的对象（`u`、`g`、`o` 分别代表所有者、所属用户组、其他用户），`operator` 是操作符（`+`、`-`、`=`），`permissions` 是要设置的权限（`r`、`w`、`x`）。

例如，要为文件 `file.txt` 添加其他用户的写权限，可以使用以下命令：

```
chmod o+w file.txt

# 指定多个
chmod u+rwx,g+rw,o+r file.txt
```

### `chgrp` 命令

`chgrp` 命令用于更改文件或目录的所属用户组。它是"change group"的缩写。`chgrp` 命令的详细用法如下：

```
chgrp [-R] 新用户组 文件名
```

- **-R**：可选，递归地更改指定目录及其子目录中所有文件和目录的所属用户组。
- **新用户组**：指定要更改为的新用户组名称或用户组 ID。

例如，要将文件 `file.txt` 的所属用户组更改为 `newgroup`，您可以使用以下命令：

```
chgrp newgroup file.txt
```

要递归地更改目录 `mydir` 及其所有子目录和文件的所属用户组为 `newgroup`，您可以使用以下命令：

```
chgrp -R newgroup mydir
```

## 文件压缩打包

### `tar` 命令

`tar` 命令在 Linux 中用于打包文件和目录，并且可以选择是否压缩。以下是 `tar` 命令的详细用法：

1. **打包文件或目录**：

   - 基本语法：`tar -cvf <目标文件> <源文件或目录>`
   - 参数说明：
     - `-c`：创建新的归档文件
     - `-v`：显示详细信息，可以查看打包过程中的文件列表
     - `-f`：指定归档文件的名称

   例如，要将 `folder1` 目录打包成 `archive.tar` 文件，可以使用以下命令：

   ```
   tar -cvf archive.tar folder1
   ```

2. **解压文件**：

   - 基本语法：`tar -xvf <压缩文件>`
   - 参数说明：
     - `-x`：解压归档文件
     - `-v`：显示详细信息，可以查看解压过程中的文件列表
     - `-f`：指定归档文件的名称

   例如，要解压名为 `archive.tar` 的归档文件，可以使用以下命令：

   ```
   tar -xvf archive.tar
   ```

3. **常用选项**：

   - `-z`：通过 gzip 压缩/解压文件，创建 `.tar.gz` 格式的压缩文件
   - `-j`：通过 bzip2 压缩/解压文件，创建 `.tar.bz2` 格式的压缩文件
   - `-C`：在指定路径解压文件
   - `-t`：列出归档文件中的内容，不解压

   例如，要通过 gzip 压缩文件并创建 `.tar.gz` 格式的压缩文件，可以使用以下命令：

   ```
   tar -czvf archive.tar.gz folder1
   ```

### `gzip` 命令

`gzip` 命令用于压缩文件，通常用于创建 `.gz` 格式的压缩文件。以下是 `gzip` 命令的具体用法：

1. **压缩文件**：

   - 基本语法：`gzip <文件>`
   - 例如，要压缩名为 `file.txt` 的文件，可以使用以下命令：

   ```
   gzip file.txt
   ```

   这将生成名为 `file.txt.gz` 的压缩文件。

2. **解压文件**：
   - 基本语法：`gzip -d <压缩文件>`
   - 例如，要解压名为 `file.txt.gz` 的压缩文件，可以使用以下命令：
   ```
   gzip -d file.txt.gz
   ```
   这将解压该文件并恢复原始的 `file.txt` 文件。

### `zip` 命令

用于创建和管理 ZIP 格式压缩文件的命令行工具

1. **创建 ZIP 压缩文件**：

   - 基本语法：`zip <压缩文件名> <要压缩的文件或目录>`
   - 例如，要将名为 `folder` 的目录压缩为 `folder.zip`，可以使用以下命令：

   ```
   zip -r folder.zip folder
   ```

   `-r` 选项用于递归地压缩整个目录。

2. **解压 ZIP 压缩文件**：
   - 基本语法：`unzip <压缩文件名>`
   - 例如，要解压名为 `folder.zip` 的压缩文件，可以使用以下命令：
   ```
   unzip folder.zip
   ```

### `bzip2` 命令

1. **压缩文件**：

   - 基本语法：`bzip2 <文件>`
   - 例如，要压缩名为 `file.txt` 的文件，可以使用以下命令：

   ```
   bzip2 file.txt
   ```

   这将生成名为 `file.txt.bz2` 的压缩文件。

2. **解压文件**：
   - 基本语法：`bzip2 -d <压缩文件>`
   - 例如，要解压名为 `file.txt.bz2` 的压缩文件，可以使用以下命令：
   ```
   bzip2 -d file.txt.bz2
   ```
   这将解压该文件并恢复原始的 `file.txt` 文件。

## 进程管理

进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。

进程管理最重要的就是 `ps` 命令：

- `ps aux`：查看系统中所有进程，使用 BSD 操作系统格式。
- `ps -le`：查看系统中所有进程，使用 Linux 标准命令格式。
- `ps -l`：仅查看自己的 bash 相关的进程。

常用的参数：

- -a：显示所有用户的进程。
- -e：显示所有进程。
- -f：用完整格式显示进程信息。
- -l：用长格式显示进程信息。
- -u：显示指定用户的进程信息。
- -x：显示没有控制终端的进程。

`ps aux` 命令输出大约如下图所示：

![](https://cdn.jsdelivr.net/gh/qiqihaobenben/picture/2021-9-1/1630462129937-image.png)

输出的格式含义：

- USER：该进程是由哪个用户产生的；
- PID：进程的 ID；
- %CPU：进程占 CPU 资源的百分比；
- %MEM：进程占用物理内存的百分比；
- VSZ：进程占虚拟内存的大小，单位 KB；
- RSS：进程占用实际物理内存的大小，单位 KB；
- TTY：进程在哪个终端运行的，tty1-tty7 代表本地控制台终端，tty1-tty6 是本地的字符界面终端（命令行），tty7 是图形终端，pts/0-255 代表虚拟终端，如果是 ? 则代表是系统进程。
- STAT：进程状态，R-运行，S-睡眠，T-停止，s-包含子进程，+-位于后台；
- START：进程启动时间；
- TIME：进程占用 CPU 的运行时间，注意不是系统时间；
- COMMAND：产生此进程的命令名；

### pstree

`pstree` 命令，可以显示进程树

### top

`top` 命令，可以查看系统的健康状态，跟 Windows 系统中的系统管理器类似。

`top` 命令的交互模式中可以执行下面的命令（需要注意大小写）：

- `?`/`h`：显示交互模式的帮助；
- `P`：以 CPU 使用率排序，默认就是此项；
- `M`：以内存的使用率排序；
- `N`：以 PID 排序；
- `q`：退出 `top`;

![](https://cdn.jsdelivr.net/gh/qiqihaobenben/picture/2021-9-1/1630470666169-image.png)

参照上图说一些字段的含义：

- load average 后面的三个数字的意思，分别为系统在之前 1 分钟，5 分钟，15 分钟的平均负载，一般认为小于 1 时，负载较小。如果大于 1，系统已经超过负载。如果是多核 CPU，那么这个数字应该不大于你的 CPU 核心数，比如双核 CPU 时应该不大于 2。
- Tasks 后面的 zombie，意思为僵尸进程，一般是进程无法正常运行，也没有正常退出，通俗的说就是卡住了，也有可能这个进程正在终止过程中，如果稍微等待一下还存在，那么就需要手动检查一下。
- %CPU(s)的 id 是比较重要的指标，以为空闲 CPU 的百分比，如果低于 20，那么系统的状态就比较卡了。

### 杀死进程

杀死进程主要有下面几个命令：

| 命令      | 作用                                               |
| --------- | -------------------------------------------------- |
| `kill`    | 杀死某个进程                                       |
| `killall` | 按照进程名杀死进程                                 |
| `pkill`   | 按照进程名杀死进程，加 `-t` 可以按照终端号踢出用户 |

杀死进程时可以跟信号，常用的信号如下：

| 信号代号 | 信号名称 | 说明                                                                                                    |
| -------- | -------- | ------------------------------------------------------------------------------------------------------- |
| 1        | SIGHUP   | 让进程立即关闭，然后重新读取配置文件之后重启，平滑重启                                                  |
| 2        | SIGINT   | 程序终止信号，用于终止前台进程，相当于 ctrl + c 快捷键                                                  |
| 9        | SIGKILL  | 强制终止，用来立即结束程序的运行，本信号不能被屏蔽、处理和忽略                                          |
| 15       | SIGTERM  | 正常结束的信号，`kill` 命令默认就是这个信号，有时候进程已经发生问题，正常无法终止，此时会使用 `-9` 信号 |

### 修改进程优先级

可以使用 `ps -le | less` 查看进程的优先级：

![](https://cdn.jsdelivr.net/gh/qiqihaobenben/picture/2021-9-1/1630491191110-image.png)

下面的两个值都是优先级，数字越小代表改进程优先级越高。

- PRI 代表 Priority，用户不能修改

- NI 代表 Nice，用户可以修改，NI 值的返回是-20 到 19，普通用户调整 NI 值的范围是 0-19，并且只能调整自己的进程，root 用户才能设定进程 NI 值为负值。

可以使用 `nice` 命令来修改优先级，`nice <选项> 命令`，选项 `-n 值` 给命令赋予 NI 值。nice 命令可以给新执行的命令直接赋予 NI 值，但是不能修改已存在的 NI 值的进程。例如，修改 apache 的进程优先级 `nice -n 5 service httpd start`。

如果要修改已存在的进程的优先级，需要使用 `renice` 命令， `renice <优先级> PID`，PID 为某一个进程的 ID。例如：`renice -10 2125` 修改 ID 2125 的进程 NI 值为 -10。

## 工作管理

- 当前的登录终端，只能管理当前终端的工作，而不能管理其他登录终端的工作；
- 放入后台的命令必须可以持续运行一段时间，这样我们才能捕捉和操作这个工作；
- 放入后台执行的命令不能和前台用户有交互或者需要前台输入，否则放入后台只能暂停，而不能执行；

### 把进程放入后台有两个主要命令：

1. `<命令> &` 把命令放入后台，并在后台执行
2. `<命令>` 执行后按下 ctrl + z 快捷键，放入后台暂停

查看正在后台的工作，可以使用 `jobs [-l]` 命令， `-l` 是显示工作的 PID。

### 恢复操作：

- `fg %工作号` 将后台暂停的工作恢复到前台执行，这里的 % 可以省略，不过要注意工作号和 PID 的区别（工作号类似于 1，2 这样的序号）；
- `bg %工作号` 将后台暂停的工作恢复到后台执行，后台恢复执行的命令，是不能和前台有交互的，否则不能恢复到后台执行；

### 让程序始终在后台执行

如果让程序始终在后台执行，即使关闭当前的终端也执行（之前的 `&` 做不到），有以下三种方法可以实现：

1. 把需要后台执行的命令加入 `/etc/rc.local` 文件；
2. 使用系统定时任务，让系统在指定的时间执行某个后台命令；
3. 使用 `nohup` 命令，该命令可以是在你退出账户/关闭终端之后继续运行相应的进程

`nohup` 命令的使用方法 `nohup <命令> &` ，nohup.out 日志可以使用 `tail -fn nohub.out` 查看

关闭终端后，在另一个终端 `jobs` 已经无法看到后台跑的程序了，此时利用 `ps aux` 可以看到所有进程。

关于前台后台进程切换，可以查看：[Linux 程序前台后台切换](https://www.cnblogs.com/geogre123/p/10643152.html)

## 网络相关

mac 查看自己的公网 ip

```
curl ipinfo.io/json
```

mac 查看自己的内网 ip

```
ifconfig
```
