# Java 基础

## Java 试用

### 基本操作

1. 下载 JDK 并安装，配置环境变量

2. 创建一个 Hello.java 文件

- java 文件中类名必须跟文件名相同，类名以大写字母开头
- 一个程序中有且只有一个主方法（main）

```java
// 定义一个公有的类，类名必须跟文件名相同，类名以大写字母开头
public class Hello {
  // 定义一个 main 方法（也叫主方法），是程序的入口
  // 一个程序中有且只有一个主方法
  public static void main(String[] args) {
    // 在控制台输出一串文字，双引号中的内容就是要输出的文字内容
    System.out.println("Hello, World!");
  }
}
```

3. 编译并运行

- 编译命令：javac Hello.java
- 运行命令：java Hello

### 使用 IDE 编写代码（例如使用 IntelliJ IDEA 编写 Hello.java）

1. 创建 project，可以指定 JDK 版本
2. 在 project 目录上创建 module，也可以指定 JDK 版本
3. 在 module 目录上新建 `.java` 源代码（Java Class），设置类名并确认后，进入代码编辑页面，代码中会默认生成一个根据刚才类名创建的类，类的语句块中默认没有内容。
4. 在类中编写代码，输入 `psvm` 自动生成主方法代码，输入 `sout` 自动生成输出语句
5. 通过页面中的三角形按钮（所有）可以编译并运行当前的代码

## Java 数据类型

### 基本数据类型

#### 整型

整型也叫整数型，表示整数数据类型

- 小整型 byte
- 短整型 short
- 整型 int
- 长整型 long

#### 浮点型

表示小数数据类型

- 单精度浮点型 float
- 双精度浮点型 double

#### 字符型 char

表示单个字符类型。字符型就是平时使用的各种字符、字母、数字，以及各种标点符号。

Java 中表示字符串的时候，需要通过一对单引号将其括起来。

#### 布尔类型 boolean

表示真或假（true/false）

#### 空类型 null

也叫 NULL 类型（null），他是 Java 中一种比较特殊的常量值，通常用于引用数据类型的初始化。

### 引用数据类型

#### 字符串型 String

表示多个字符集合类型。字符串就是多个字符的集合，多个字符组成的串。

在 Java 中表示字符串的时候，需要通过一对双引号将其括起来。

#### 数组 Array

#### 类 class

#### 接口 interface

#### Lambda Lambda

### 单双引号的区别

字符串与单个字符的区别——单个字符使用单引号，而字符串使用双引号，即使双引号中只有一个字符，其表示的也是一个字符串，只不过字符串中的有效字符只有一个而已。

## Java 变量

Java 中，在我们想要使用变量之前，需要先定义一个变量，也就是需要向内存申请一块存储空间，目的是存储某些值，这些值在未来程序运行的某个时间节点可能会发生变化。

在定义变量的时候，需要指定申请的是什么类型的变量，即告诉 Java 要申请多少字节的存储空间来存储什么值。

### 变量的命名规范

### 使用变量的注意事项

#### 变量的作用域：语句块内有效

#### 变量的初始化：变量必须初始化后再使用

### 变量类型转换

#### 隐式类型转换（自动类型转换）：小转大（不丢精度）

#### 显示类型转换（需要进行强制类型转换）：大转小（可能丢精度）

## Java 运算符

- 算术运算符：`+`、`-`、`*`、`/`、`%`
- 关系运算符：`>`, `<`, `>=`, `<=`, `==`, `!=`
- 逻辑运算符：`&&`、`||`、`!`
- 赋值运算符：`=`、`+=`、`-=`、`*=`、`/=`、`%=`
- 位运算符：`&`、`|`、`^`、`~`、`<<`、`>>`
- 条件运算符：`? :`
- instanceof 运算符：`instanceof`

### 运算符优先级

https://i.bjpowernode.com/article/368.html

## Java 数组

### 定义

```java
// 第一种方法
int[] arr = new int[5];
// 第二种方法
int[] arr = {1, 2, 3, 4, 5};

```

### 初始化

### 特性

## 方法（函数）

### 概念和定义

### 使用方法的好处

### 名词解析

### 注意事项

### 方法的重载

## 面向对象

### 类和对象的概念

- 类是对象的抽象
- 对象是类的实例

### 对象的使用步骤

以 IDEA 编辑器为例

#### 1. 创建包

在创建类的时候可以先创建包，然后在包里创建自定义类。实际上，包就是项目目录中的子目录。

创建方法：在项目的 src 目录上单击右键->选择 new（新建）->选择 Packages（包）->输入包名->确认

定义包名的时候，通常使用域名逆序的排列来定义，这样能保证唯一性。（例如：com.example.xxx）

#### 2. 创建自定义类

包创建成功后，在项目目录下会出现一个新的目录，这个目录就是刚才创建的包。在包目录上单击右键->选择 new（新建）->选择 Java Class（Java 类）->输入类名->确认

在 IDEA 的包中创建类时，IDEA 会默认添加一行代码，指定当前的包名。

```java
package com.example.PersonDemo;
```

#### 3. 在使用类之前，需要实现导入这个类所在的包。语法是：`import 包名.类名;`

注意：当前使用的类和当前类处于同一个包下的时候，不需要 import，如果不在同一个包内，就需要使用 import 导入包。

另外，IDEA 会在实例化（new）对象的时候自动生成 import 语句。

#### 4. 实例化对象：`类名 对象名 = new 类名();`，之后通过对象名调用类实例属性及方法：`对象名.属性名 或 对象名.方法名`

### 类的变量和方法

- 实例（成员）变量
  - 公有实例属性
  - 私有实例属性
  - 受保护的实例属性
- 静态变量
- 局部变量
- 实例（成员）方法
  - 公有实例方法
  - 私有实例方法
  - 受保护的实例方法
- 静态方法

### 修饰符

#### 访问修饰符

- public
- private
- protected

#### 非访问修饰符

- static
- final
- abstract
- synchronized
- volatile

#### final 修饰符

final 修饰符是一种 Java 关键字，表示最终的，用于修饰类、变量和方法，用来限定其不能被继承、修改或删除。可以用来保护代码和数据的安全性。

final 修饰符在以下几种场景中可以具体使用：

1. 类：当声明一个类为 final 时，它就成为一个不可变类，不能被其它类继承。
2. 方法：当声明一个方法为 final 时，它就不能被子类重写。
3. 变量：当声明一个变量为 final 时，它就成为一个常量，不能被修改。

##### 使用语法

```
[modifier] final class ClassName
[modifier] final [type] variableName
[modifier] final returnType methodName(parameters)
```

##### 注意事项

- 使用 final 修饰符的时候需要注意以下几点：
- 不要试图修改一个 final 变量，因为它是一个常量，只能被初始化一次。
- 当使用 final 修饰符修饰一个方法时，该方法就不能被子类重写。
- 不要尝试继承一个 final 类，因为它不能被继承。
- 尽量不要把一个类声明为 final，因为这样会限制类的扩展性。
- 使用 final 修饰的引用类型的变量不能被重新赋值（仅仅保证变量的地址不变），但可以改变引用类型所引用对象的内容。

### 构造方法

#### 构造方法特点

### 继承（复习一下 JavaScript 的继承）

#### 继承的特点

#### 父类、子类、局部变量名重复、冲突时的访问规则

#### 继承中的权限

## 抽象（abstract）

在 Java 中，`abstract` 是一个修饰符，用 `abstract` 修饰的类叫抽象类，用 `abstract` 修饰的方法叫作抽象方法。

### abstract 注意事项

## 接口（interface）

接口（interface）是一种公共的规范，是一种引用数据类型。

### 接口的定义

### 接口中的成员

#### 接口中的常量

#### 接口中的抽象方法

#### 接口中的默认方法

#### 接口中的静态方法

#### 接口中的私有方法

### 接口的实现

#### 实现接口的格式

## 多态

### 格式

### 多态调用成员方法

### 多态调用成员属性

### 对象的上下转型

## 内部类

Java 中的内部类是一种特殊的类，它定义在另一个类的内部，即在一个类中定义另一个类，这个在类中定义的类就叫做内部类

内部类可以访问外部类的所有成员变量和方法，即使它们是私有的（private）、静态的（static）。

外部类是指定义在另一个类外部的类。一个外部类可以有多个内部类，而一个内部类也可以嵌套其他内部类

### 格式

### 内部类的访问特点

### 内部类的分类

根据内部类在类中定义的位置不同

- 成员内部类 ： 在类的成员位置
  - 静态成员内部类 ： 使用 static 修饰符
  - 非静态成员内部类 ： 没有使用 static 修饰符
- 局部内部类 ： 在类的局部位置（在成员方法中）
- 匿名内部类

#### 静态成员内部类和非晶态成员内部类的区别

还有其他的 https://blog.csdn.net/liuxiao723846/article/details/108006609

非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外部类的对象，但是静态内部类却没有。

静态内部类没有这个引用就意味着：

- 它的创建是不需要依赖于外部类的对象
- 它不能使用任何外部类的非 static 成员变量和方法（因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非 static 成员就会产生矛盾，因为外部类的非 static 成员必须依附于具体的对象）
- 静态内部类内允许有 static 属性、方法；

#### 局部内部类

局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。

## 常用类

### 基本类型的包装类

Byte、Short、Integer、Long、Float、Double、Boolean、Character

它们的具体含义如下所示：

- Byte：表示一个字节，取值范围为-128~127。
- Short：表示一个短整型，取值范围为-32768~32767。
- Integer：表示一个整型，取值范围为-2147483648~2147483647。
- Long：表示一个长整型，取值范围为-9223372036854775808~9223372036854775807。
- Float：表示单精度浮点数，取值范围为 1.4e-45~3.4028235e38。
- Double：表示双精度浮点数，取值范围为 4.9e-324~1.7976931348623157e308。
- Boolean：表示布尔值，取值范围为 true 和 false。
- Character：表示字符，取值范围为 0~65535。

#### 拆箱

拆箱是指将包装类对象转换为基本类型数据的操作。此操作可以通过调用基本类型的值来实现，如 intValue(),doubleValue() 等。

#### 装箱

装箱是指将基本类型数据转换为包装类对象的操作，它可以通过调用包装类的静态方法 valueOf()来实现。

### String 类

无论是常量还是变量，只要是字符串，在 Java 中就都是字符串对象。

#### 字符串类的特点

#### String 对象的特点

#### StringBuilder

## 集合

### 单列集合 Collection

#### List

值可以重复

- ArrayList
- LinkedList

#### Set

值不可重复

- HashSet
- LinkedHashSet
- TreeSet

### 双列集合 Map

双列集合，就是常说的键值对集合，在存储的时候都是一个键对应一个值，键是不可以重复的，值是可以重复的。所以在 Map 集合中，键是具备唯一性的。

- HashMap
- HashTable
- LinkedHashMap
- TreeMap

#### HashMap

HashMap 是一种常用的哈希表实现，它使用哈希算法存储键值对，允许使用 null 值和 null 键，提供快速的查找和插入操作。HashMap 是非线程安全的，不支持顺序遍历。

#### HashTable

HashTable 是一种古老的哈希表实现，它使用哈希算法存储键值对，不允许使用 null 值和 null 键，提供快速的查找和插入操作。HashTable 是线程安全的，不支持顺序遍历。

#### LinkedHashMap

LinkedHashMap 是一种哈希表实现，它使用哈希算法存储键值对，允许使用 null 值和 null 键，提供快速的查找和插入操作。LinkedHashMap 支持顺序遍历，但不是线程安全的。

#### TreeMap

TreeMap 是一种基于红黑树实现的有序哈希表，它使用键的自然顺序或者比较器来排序键值对，提供快速的查找和插入操作。TreeMap 是非线程安全的，支持顺序遍历。

根据实际情况，可以根据以下几点来选择不同的哈希表实现：

- 是否需要线程安全性：如果需要，则可以选择 HashTable；如果不需要，则可以选择 HashMap 或者 LinkedHashMap 等。

- 是否需要排序：如果需要，则可以选择 TreeMap 或者 LinkedHashMap；如果不需要，则可以选择 HashMap 或者 HashTable。

- 是否允许 null 值和 null 键：如果允许，则可以选择 HashMap 或者 LinkedHashMap；如果不允许，则可以选择 HashTable 或者 TreeMap。
