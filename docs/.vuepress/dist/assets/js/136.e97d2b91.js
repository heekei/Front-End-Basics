(window.webpackJsonp=window.webpackJsonp||[]).push([[136],{568:function(t,s,a){"use strict";a.r(s);var e=a(25),n=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"现代框架的分类与解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#现代框架的分类与解析"}},[t._v("#")]),t._v(" 现代框架的分类与解析")]),t._v(" "),s("h2",{attrs:{id:"前端框架的实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前端框架的实现原理"}},[t._v("#")]),t._v(" 前端框架的实现原理")]),t._v(" "),s("p",[t._v("现代框架的实现原理基本上可以概括为：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("UI = f(state)\n")])])]),s("ul",[s("li",[t._v("state：当前视图状态")]),t._v(" "),s("li",[t._v("f：框架内部运行机制")]),t._v(" "),s("li",[t._v("UI：宿主环境的视图")])]),t._v(" "),s("p",[t._v("这个公式可以解释为：框架内部运行机制根据当前状态渲染视图。")]),t._v(" "),s("p",[t._v("框架内部运行机制 f 的工作原理分为两步：")]),t._v(" "),s("ol",[s("li",[t._v("根据自变量（state）变化计算出 UI 变化；")]),t._v(" "),s("li",[t._v("根据 UI 变化执行具体的宿主环境 API；")])]),t._v(" "),s("h2",{attrs:{id:"现代框架的分类标准"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#现代框架的分类标准"}},[t._v("#")]),t._v(" 现代框架的分类标准")]),t._v(" "),s("p",[t._v("从 f 的工作原理来看，第二步，在浏览器环境中，“UI 的增删改查”是通过 DOM API 实现的，这一步骤，不同前端框架的实现基本一致，不能作为框架分类依据。")]),t._v(" "),s("p",[t._v("不同框架的差异主要体现在步骤 1 的实现上。")]),t._v(" "),s("p",[t._v("一般规律可以总结为：前端框架需要关注“自变量与 X 的对应关系”。随着 X 抽象层级不断下降，“自变量到 UI 变化”的路径增多。路径越多，意味着前端框架在运行时消耗在寻找“自变量与 UI 的对应关系”上的时间越少。")]),t._v(" "),s("p",[t._v("前端框架中“与自变量建立对应关系的抽象层级”可以作为其分类依据，按照这个标准，前端框架可以分为以下三类：")]),t._v(" "),s("p",[t._v("应用级框架：建立“自变量与应用对应关系”的框架，称为应用级框架，例如 React\n组件级框架：建立“自变量与组件对应关系”的框架，称为组件级框架，例如 Vue\n元素级框架：建立“自变量与 UI（元素） 对应关系”的框架，称为元素级框架，例如 Svelte 与 Solid.js")]),t._v(" "),s("h2",{attrs:{id:"现代框架组织-ui-与-逻辑的方式-组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#现代框架组织-ui-与-逻辑的方式-组件"}},[t._v("#")]),t._v(" 现代框架组织 UI 与 逻辑的方式——组件")]),t._v(" "),s("p",[t._v("现代框架为了实现 UI 和 逻辑的关注点分离，需要一种存放 UI 与逻辑的松散耦合单元，这就是组件。")]),t._v(" "),s("p",[t._v("从自变量和因变量的角度分析组件")]),t._v(" "),s("h3",{attrs:{id:"组件如何组织逻辑与-ui"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件如何组织逻辑与-ui"}},[t._v("#")]),t._v(" 组件如何组织逻辑与 UI？")]),t._v(" "),s("h4",{attrs:{id:"自变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自变量"}},[t._v("#")]),t._v(" 自变量")]),t._v(" "),s("p",[t._v("现代框架自变量普遍由 getter（取值）与 setter（赋值）两部分组成")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 初始值为 0 的自变量 x")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" setX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("useState")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 取值")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 赋值")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setX")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h4",{attrs:{id:"因变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#因变量"}},[t._v("#")]),t._v(" 因变量")]),t._v(" "),s("p",[t._v("自变量变化会导致“依赖它的因变量”变化，因变量有两种类型：")]),t._v(" "),s("ul",[s("li",[t._v("无副作用因变量")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 定义依赖 x 的无副作用因变量 y")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" y "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("useMemo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 取值")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("ul",[s("li",[t._v("有副作用因变量")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当依赖的 x 变化，修改页面标题（副作用）")]),t._v("\n")])])]),s("blockquote",[s("p",[t._v("副作用：函数式编程概念，是指在函数执行过程中产生对外部环境的影响。如果一个函数同时满足如下条件，则称这个函数为“纯函数”：1、相同的输入始终获得相同的输出；2、不会修改程序的状态或者产生副作用。")])]),t._v(" "),s("h4",{attrs:{id:"三种组织逻辑与-ui-的方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三种组织逻辑与-ui-的方式"}},[t._v("#")]),t._v(" 三种组织逻辑与 UI 的方式")]),t._v(" "),s("ol",[s("li",[t._v("逻辑中的自变量变化，导致 UI 变化；")]),t._v(" "),s("li",[t._v("逻辑中的自变量变化，导致“无副作用因变量”变化，导致 UI 变化；")]),t._v(" "),s("li",[t._v("逻辑中的自变量变化，导致“有副作用因变量”变化，导致副作用。")])]),t._v(" "),s("h3",{attrs:{id:"如何在组件之间传递数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何在组件之间传递数据"}},[t._v("#")]),t._v(" 如何在组件之间传递数据")]),t._v(" "),s("p",[t._v("数据在组件之间的传输方式是：组件的自变量或因变量通过 UI 传递给另一个组件，作为另一个组件的自变量。")]),t._v(" "),s("p",[t._v("为了区分不同方式产生的自变量，在前端框架中：")]),t._v(" "),s("ul",[s("li",[t._v("“组件内部定义的自变量”通常被称为 state（状态）")]),t._v(" "),s("li",[t._v("“由其他组件传递而来的自变量”被称为 props（属性）")])]),t._v(" "),s("h4",{attrs:{id:"为了解决层层传递的问题-也可以通过-store-传递自变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为了解决层层传递的问题-也可以通过-store-传递自变量"}},[t._v("#")]),t._v(" 为了解决层层传递的问题，也可以通过 store 传递自变量")]),t._v(" "),s("p",[t._v("store 在本质上也是自变量，相比 state，它能够实现跨层级传递。不同的框架中，store 的实现方案不同，在 React 中使用 store 需要遵循三个步骤：")]),t._v(" "),s("ol",[s("li",[t._v("在 A 的逻辑中调用 React.createContext 创建 context")]),t._v(" "),s("li",[t._v("在 A 的 UI 中定义 context.provider")]),t._v(" "),s("li",[t._v("在 C 的逻辑中通过 useContext 消费 A 传递过来的自变量")])])])}),[],!1,null,null,null);s.default=n.exports}}]);