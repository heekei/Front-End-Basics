(window.webpackJsonp=window.webpackJsonp||[]).push([[214],{672:function(a,t,s){"use strict";s.r(t);var e=s(25),r=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"正则表达式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式"}},[a._v("#")]),a._v(" 正则表达式")]),a._v(" "),t("h2",{attrs:{id:"基本概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[a._v("#")]),a._v(" 基本概念")]),a._v(" "),t("h3",{attrs:{id:"概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[a._v("#")]),a._v(" 概念")]),a._v(" "),t("p",[a._v("正则表达式（Regular Expression），简称 regex，是一种特殊的文本模式（特定的规则、模板或结构），用于在"),t("strong",[a._v("字符串")]),a._v("中搜索、匹配和替换文本。")]),a._v(" "),t("h3",{attrs:{id:"正则表达式在计算机领域的发展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式在计算机领域的发展"}},[a._v("#")]),a._v(" 正则表达式在计算机领域的发展")]),a._v(" "),t("h4",{attrs:{id:"发展史"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发展史"}},[a._v("#")]),a._v(" 发展史")]),a._v(" "),t("ul",[t("li",[a._v("20 世纪 40 年代，两个神经生理学家研究出了一种用数学方式来描述神经网络的方法，可以将神经系统中的神经元描述成小而简单的自动控制元。")]),a._v(" "),t("li",[a._v('20 世纪 50 年代，Stephen Kleene 在以上两位的基础上发表了《神经网络事件表示法和有穷自动机》 论文。这篇论文描述了一种叫做 "正则集合（Regular Sets）" 的数学符号，引入了正则表达式的概念。')]),a._v(" "),t("li",[a._v("20 世纪 60 年代，Unix 之父 Ken Thompson 发表了 《正则表达式搜索算法》 论文。并应用在文本搜索工具 grep 中。")]),a._v(" "),t("li",[a._v("20 世纪 70 年代，由于 grep 支持的功能不多，出现了 egrep 、 awk 、 lex 、 sed 等，每个程序所支持的正则表达式都有差别。")]),a._v(" "),t("li",[a._v("20 世纪 80 年代，"),t("code",[a._v("POSIX")]),a._v("（Portable Operating System Interface）标准公布，其中就包含不同操作系统都需要遵守的正则表达式规范。")]),a._v(" "),t("li",[a._v("20 世纪 90 年代，在 80 年代发布的 Perl 编程语言，引入了正则表达式功能，并随着语言的发展越来越强大，为了把 Perl 语言的正则表达式功能移植到其他语言中，诞生了开源项目 "),t("code",[a._v("PCRE")]),a._v("（Perl Compatiable Regular Expressions）")])]),a._v(" "),t("h4",{attrs:{id:"正则表达式规范分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式规范分类"}},[a._v("#")]),a._v(" 正则表达式规范分类")]),a._v(" "),t("p",[a._v("遵循 POSIX 规则的正则表达式，称为 POSIX 派系的正则表达式。Unix 系统或类 Unix 系统上的大部分工具，如 grep 、sed 、awk 等都属于 POSIX 派系。")]),a._v(" "),t("p",[a._v("遵循 PCRE 规范的正则表达式，成为 PCRE 派系的正则表达式。现代编程语言如 Python ， Ruby ， PHP ， C / C++ ， Java 等正则表达式，大部分都属于 PCRE 派系，或参照 PCRE 派系发展而来。")]),a._v(" "),t("h5",{attrs:{id:"posix-派系分为两个标准"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#posix-派系分为两个标准"}},[a._v("#")]),a._v(" POSIX 派系分为两个标准")]),a._v(" "),t("ul",[t("li",[a._v("BRE 标准（Basic Regular Expression 基本正则表达式）")]),a._v(" "),t("li",[a._v("ERE 标准（Extended Regular Expression 扩展正则表达式）")])]),a._v(" "),t("h5",{attrs:{id:"pcre-跟-posix-相比有哪些优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pcre-跟-posix-相比有哪些优势"}},[a._v("#")]),a._v(" PCRE 跟 POSIX 相比有哪些优势？")]),a._v(" "),t("p",[a._v("PCRE 使用起来更加易用简洁（不需要转义，有更简洁字符组），功能更加丰富（非捕获组，环顾断言，非贪婪）。如果没有特殊原因，应尽可能使用 PCRE 派系，让正则匹配的结果更符合我们预期。")]),a._v(" "),t("h5",{attrs:{id:"不同正则表达式规格和引擎的区别概览"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不同正则表达式规格和引擎的区别概览"}},[a._v("#")]),a._v(" 不同正则表达式规格和引擎的区别概览")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://deerchao.cn/tutorials/regex/diffs.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("正则表达式引擎/风味对比"),t("OutboundLink")],1)]),a._v(" "),t("h2",{attrs:{id:"基础语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础语法"}},[a._v("#")]),a._v(" 基础语法")]),a._v(" "),t("h3",{attrs:{id:"创建方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建方式"}},[a._v("#")]),a._v(" 创建方式")]),a._v(" "),t("h4",{attrs:{id:"regexp-字面量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#regexp-字面量"}},[a._v("#")]),a._v(" RegExp 字面量")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" reg "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("hello")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-flags"}},[a._v("i")])]),a._v("\n")])])]),t("h4",{attrs:{id:"regexp-构造函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#regexp-构造函数"}},[a._v("#")]),a._v(" RegExp() 构造函数")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" reg "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("RegExp")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'hello'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'i'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),t("h5",{attrs:{id:"new-regexp-创建字面量形式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#new-regexp-创建字面量形式"}},[a._v("#")]),a._v(" new RegExp() 创建字面量形式")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" regex "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("RegExp")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("xyz")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-flags"}},[a._v("i")])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 等价于")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" regex "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("xyz")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-flags"}},[a._v("i")])]),a._v("\n")])])]),t("p",[a._v("其实还有一种形式的字面量 "),t("code",[a._v("new RegExp(/xyz/i)")]),a._v(" ，注意第一个参数不是字符串，而是正则表达式字面量。")]),a._v(" "),t("p",[a._v("这样的写法就会存在正则表达式字面量中修饰符和 RegExp 构造函数第二个参数冲突的情况。在 ES5 中不允许此时使用第二个参数添加修饰符，否则会报错。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var regex = new RegExp(/xyz/, 'i');\n// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another\n")])])]),t("p",[a._v("ES6 改变了这种行为。如果 RegExp 构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("new RegExp(/abc/ig).flags // gi\nnew RegExp(/abc/ig, 'i').flags // i ，原有正则对象的修饰符是ig，它会被第二个参数i覆盖\n")])])]),t("h4",{attrs:{id:"字面量和构造函数的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字面量和构造函数的区别"}},[a._v("#")]),a._v(" 字面量和构造函数的区别")]),a._v(" "),t("ul",[t("li",[a._v("反斜杠 "),t("code",[a._v("\\")]),a._v(" 进行转义时，字面量语法需要一个反斜杠 "),t("code",[a._v("\\")]),a._v(" ，而 "),t("code",[a._v("RegExp")]),a._v(" 构造函数需要两个反斜杠 "),t("code",[a._v("\\\\")]),a._v("（因为字符串内部会先转义一次）")])]),a._v(" "),t("p",[a._v("例如：匹配字符串 "),t("code",[a._v("1+1=2")])]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" str "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'1+2=3'")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" reg1 "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("1\\+2=3")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")])]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" reg2 "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("RegExp")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'1\\\\+2=3'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 两个反斜杠")]),a._v("\nreg1"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("test")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("str"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\nreg2"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("test")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("str"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),t("p",[a._v("以下是常见需要转义的字符：")]),a._v(" "),t("ol",[t("li",[a._v("反斜杠 ("),t("code",[a._v("\\")]),a._v(")：用于开始一个转义序列。")]),a._v(" "),t("li",[a._v("点 ("),t("code",[a._v(".")]),a._v(")：匹配除换行符之外的任何单个字符。")]),a._v(" "),t("li",[a._v("星号 ("),t("code",[a._v("*")]),a._v(")：表示零次或多次匹配前面的元素。")]),a._v(" "),t("li",[a._v("加号 ("),t("code",[a._v("+")]),a._v(")：表示一次或多次匹配前面的元素。")]),a._v(" "),t("li",[a._v("问号 ("),t("code",[a._v("?")]),a._v(")：表示零次或一次匹配前面的元素；也用于表示非贪婪匹配。")]),a._v(" "),t("li",[a._v("圆括号 ("),t("code",[a._v("(")]),a._v(" 和 "),t("code",[a._v(")")]),a._v(")：用于分组。")]),a._v(" "),t("li",[a._v("方括号 ("),t("code",[a._v("[")]),a._v(" 和 "),t("code",[a._v("]")]),a._v(")：用于定义字符集。")]),a._v(" "),t("li",[a._v("花括号 ("),t("code",[a._v("{")]),a._v(" 和 "),t("code",[a._v("}")]),a._v(")：用于指定数量限定符。")]),a._v(" "),t("li",[a._v("竖线 ("),t("code",[a._v("|")]),a._v(")：表示选择（或）。")]),a._v(" "),t("li",[a._v("脱字符 ("),t("code",[a._v("^")]),a._v(")：表示行的开始；在字符集中用来表示否定。")]),a._v(" "),t("li",[a._v("美元符号 ("),t("code",[a._v("$")]),a._v(")：表示行的结束。")]),a._v(" "),t("li",[a._v("正斜杠 ("),t("code",[a._v("/")]),a._v(")：如果你在 "),t("code",[a._v("/")]),a._v(" 之间使用正则表达式，也需要转义。")])]),a._v(" "),t("ul",[t("li",[t("p",[a._v("字面量语法在性能方面更有优势，如果正则表达式在代码中是固定的，不需要动态生成，那么使用字面量语法（如 "),t("code",[a._v("/pattern/flags")]),a._v("）通常更高效，因为 JavaScript 引擎会在脚本加载时编译它们。相比之下，使用 "),t("code",[a._v("RegExp")]),a._v(" 构造函数创建的正则表达式可能会在每次使用时都重新编译。")])]),a._v(" "),t("li",[t("p",[a._v("字面量语法更简洁方便和直观")])]),a._v(" "),t("li",[t("p",[t("code",[a._v("RegExp")]),a._v(" 构造函数的最大的优势是能够动态地生成正则表达式。你可以在运行时根据变量或表达式构造一个正则表达式，这在使用字面量形式时做不到。")])])]),a._v(" "),t("h3",{attrs:{id:"字面量字符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字面量字符"}},[a._v("#")]),a._v(" 字面量字符")]),a._v(" "),t("p",[a._v("如果在正则表达式中，某个字符只表示它字面的含义，那他们就叫做字面量字符（Literal Characters）")]),a._v(" "),t("p",[a._v("例如下面代码中正则表达式的 d、 o 、g 三个字符，就是字面量字符")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/dog/.test('old dog') // true\n")])])]),t("h3",{attrs:{id:"元字符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#元字符"}},[a._v("#")]),a._v(" 元字符")]),a._v(" "),t("p",[a._v("有一部分字符有特殊含义，不代表字面的意思，这些字符就是元字符（Meta Characters），元字符有以下几种：")]),a._v(" "),t("ol",[t("li",[a._v("反斜杠 ("),t("code",[a._v("\\")]),a._v(")：用于开始一个转义序列。")]),a._v(" "),t("li",[a._v("点 ("),t("code",[a._v(".")]),a._v(")：匹配除换行符之外的任何单个字符。")]),a._v(" "),t("li",[a._v("星号 ("),t("code",[a._v("*")]),a._v(")：表示零次或多次匹配前面的元素。")]),a._v(" "),t("li",[a._v("加号 ("),t("code",[a._v("+")]),a._v(")：表示一次或多次匹配前面的元素。")]),a._v(" "),t("li",[a._v("问号 ("),t("code",[a._v("?")]),a._v(")：表示零次或一次匹配前面的元素；也用于表示非贪婪匹配。")]),a._v(" "),t("li",[a._v("圆括号 ("),t("code",[a._v("(")]),a._v(" 和 "),t("code",[a._v(")")]),a._v(")：用于分组。")]),a._v(" "),t("li",[a._v("方括号 ("),t("code",[a._v("[")]),a._v(" 和 "),t("code",[a._v("]")]),a._v(")：用于定义字符集。")]),a._v(" "),t("li",[a._v("花括号 ("),t("code",[a._v("{")]),a._v(" 和 "),t("code",[a._v("}")]),a._v(")：用于指定数量限定符。")]),a._v(" "),t("li",[a._v("竖线 ("),t("code",[a._v("|")]),a._v(")：表示选择（或）。")]),a._v(" "),t("li",[a._v("脱字符 ("),t("code",[a._v("^")]),a._v(")：表示行的开始；在字符集中用来表示否定。")]),a._v(" "),t("li",[a._v("美元符号 ("),t("code",[a._v("$")]),a._v(")：表示行的结束。")])]),a._v(" "),t("h3",{attrs:{id:"转义符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#转义符"}},[a._v("#")]),a._v(" 转义符")]),a._v(" "),t("p",[a._v("正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配字符串 "),t("code",[a._v("+")]),a._v("，就要写成 "),t("code",[a._v("\\+")]),a._v("。")]),a._v(" "),t("p",[a._v("正则表达式中，需要反斜杠转义的，一共有 12 个字符：反斜杠 ("),t("code",[a._v("\\")]),a._v(")、点 ("),t("code",[a._v(".")]),a._v(")、星号 ("),t("code",[a._v("*")]),a._v(")、加号 ("),t("code",[a._v("+")]),a._v(")、问号 ("),t("code",[a._v("?")]),a._v(")、圆括号 ("),t("code",[a._v("(")]),a._v(" 和 "),t("code",[a._v(")")]),a._v(")、方括号 ("),t("code",[a._v("[")]),a._v(" 和 "),t("code",[a._v("]")]),a._v(")、花括号 ("),t("code",[a._v("{")]),a._v(" 和 "),t("code",[a._v("}")]),a._v(")、竖线 ("),t("code",[a._v("|")]),a._v(")、脱字符 ("),t("code",[a._v("^")]),a._v(")、美元符号 ("),t("code",[a._v("$")]),a._v(")。"),t("strong",[a._v("需要特别注意的是，如果使用 RegExp 构造函数生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。")])]),a._v(" "),t("h5",{attrs:{id:"怎么理解因为字符串内部会先转义一次"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#怎么理解因为字符串内部会先转义一次"}},[a._v("#")]),a._v(" 怎么理解因为字符串内部会先转义一次")]),a._v(" "),t("p",[a._v("在字符串内部，反斜杠也是转义字符，所以它需要先被反斜杠转义一次。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var str = 'ab\\c\\*'\nvar str1 = 'ab\\\\c\\\\*'\nconsole.log(str) // abc* 结果是不带转译符的\nconsole.log(str1) // ab\\c\\*\n")])])]),t("h3",{attrs:{id:"点字符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#点字符"}},[a._v("#")]),a._v(" 点字符（"),t("code",[a._v(".")]),a._v("）")]),a._v(" "),t("p",[a._v("点字符（"),t("code",[a._v(".")]),a._v("）匹配除回车（"),t("code",[a._v("\\r")]),a._v("）、换行("),t("code",[a._v("\\n")]),a._v(") 、行分隔符（"),t("code",[a._v("\\u2028")]),a._v("）和段分隔符（"),t("code",[a._v("\\u2029")]),a._v("）以外的所有字符。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/c.t/.test('cat') // true\n")])])]),t("p",[t("strong",[a._v("注意：对于码点大于 0xFFFF 的 Unicode 字符，点字符不能正确匹配，会认为这是两个字符。")])]),a._v(" "),t("h3",{attrs:{id:"选择符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#选择符"}},[a._v("#")]),a._v(" 选择符（"),t("code",[a._v("|")]),a._v("）")]),a._v(" "),t("p",[a._v("竖线符号（"),t("code",[a._v("|")]),a._v("）在正则表达式中表示“或关系”（OR）。")]),a._v(" "),t("h4",{attrs:{id:"选择符会包括它前后的多个字符-注意-是多个字符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#选择符会包括它前后的多个字符-注意-是多个字符"}},[a._v("#")]),a._v(" 选择符会包括它前后的多个字符，注意，是多个字符")]),a._v(" "),t("p",[a._v("比如/ab|cd/指的是匹配 ab 或者 cd，而不是指匹配 b 或者 c")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("'abd'.match(/ab|cd/g) // 返回 ['ab']\n")])])]),t("p",[a._v("如果想要修改成单个字符，可以使用圆括号")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("'abd'.match(/a(b|c)d/g) // 返回 ['abd']\n")])])]),t("h3",{attrs:{id:"锚字符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锚字符"}},[a._v("#")]),a._v(" 锚字符")]),a._v(" "),t("p",[a._v("锚字符包含两个位置字符和两个位置预定义模式")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("^")]),a._v("：匹配字符串的开头，在多行检索中，匹配一行的开头")]),a._v(" "),t("li",[t("code",[a._v("$")]),a._v("：匹配字符串的结尾，在多行检索中，匹配一行的结尾")]),a._v(" "),t("li",[t("code",[a._v("\\b")]),a._v("：匹配词的边界")]),a._v(" "),t("li",[t("code",[a._v("\\B")]),a._v("：匹配非词边界，即在词的内部")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// \\b 的例子\n/\\bworld/.test('hello world') // true\n/\\bworld/.test('hello-world') // true\n/\\bworld/.test('helloworld') // false\n\n// \\B 的例子\n/\\Bworld/.test('hello-world') // false\n/\\Bworld/.test('helloworld') // true\n")])])]),t("p",[a._v("上面代码中，"),t("code",[a._v("\\b")]),a._v(" 表示词的边界，所以 world 的词首必须独立（词尾是否独立未指定），才会匹配。同理，"),t("code",[a._v("\\B")]),a._v(" 表示非词的边界，只有 world 的词首不独立，才会匹配。")]),a._v(" "),t("p",[a._v("其实零宽正向先行断言 "),t("code",[a._v("(?=)")]),a._v(" 和零宽负向先行断言 "),t("code",[a._v("(?!)")]),a._v(" 也属于锚字符的范畴。")]),a._v(" "),t("h3",{attrs:{id:"量词"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#量词"}},[a._v("#")]),a._v(" 量词")]),a._v(" "),t("p",[a._v("量词用来描述前面的相邻的（单个或一组）字符匹配规则出现的次数")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("{n,m}")]),a._v("：匹配前一项至少 n 次，但不能超过 m 次")]),a._v(" "),t("li",[t("code",[a._v("{n,}")]),a._v("：匹配前一项 n 次及以上")]),a._v(" "),t("li",[t("code",[a._v("{n}")]),a._v("：匹配前一项 n 次")]),a._v(" "),t("li",[t("code",[a._v("?")]),a._v("：匹配前一项 0 次或 1 次，也就是说前一项是可选的，等价于 "),t("code",[a._v("{0,1}")])]),a._v(" "),t("li",[t("code",[a._v("+")]),a._v("：匹配前一项 1 次或多次，等价于 "),t("code",[a._v("{1,}")])]),a._v(" "),t("li",[t("code",[a._v("*")]),a._v("：匹配前一项 0 次或多次，等价于 "),t("code",[a._v("{0,}")])])]),a._v(" "),t("h3",{attrs:{id:"预定义模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#预定义模式"}},[a._v("#")]),a._v(" 预定义模式")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("\\d")]),a._v("：匹配 0-9 之间的任一数字，相当于[0-9]")]),a._v(" "),t("li",[t("code",[a._v("\\D")]),a._v("：匹配所有 0-9 以外的字符，相当于[^0-9]")]),a._v(" "),t("li",[t("code",[a._v("\\w")]),a._v("：匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]")]),a._v(" "),t("li",[t("code",[a._v("\\W")]),a._v("：除所有字母、数字和下划线以外的字符，相当于[^a-za-z0-9_]")]),a._v(" "),t("li",[t("code",[a._v("\\s")]),a._v("：匹配空格（包括换行符、制表符、空格符等），相等于[ \\t\\r\\n\\v\\f]")]),a._v(" "),t("li",[t("code",[a._v("\\S")]),a._v("：匹配非空格的字符，相当于[^ \\t\\r\\n\\v\\f]")]),a._v(" "),t("li",[t("code",[a._v("\\b")]),a._v("：匹配词的边界（边界包括：空格、起始、结束）")]),a._v(" "),t("li",[t("code",[a._v("\\B")]),a._v("：匹配非词边界，即在词的内部")])]),a._v(" "),t("p",[t("strong",[a._v("扩展：跟 "),t("code",[a._v("[^]")]),a._v(" 类似，"),t("code",[a._v("[\\S\\s]")]),a._v(" 指代一切字符。")])]),a._v(" "),t("h3",{attrs:{id:"字符类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符类"}},[a._v("#")]),a._v(" 字符类")]),a._v(" "),t("p",[a._v("字符类（class）又被称为 字符组 或 字符集合，表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如 "),t("code",[a._v("[xyz]")]),a._v(" 表示 x、y、z 之中任选一个匹配")]),a._v(" "),t("h4",{attrs:{id:"方括号内的脱字符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方括号内的脱字符"}},[a._v("#")]),a._v(" 方括号内的脱字符（"),t("code",[a._v("^")]),a._v("）")]),a._v(" "),t("p",[t("code",[a._v("^")]),a._v(" 在方括号外用来匹配行的开头，但是在方括号内（开头第一个位置），则表示除了字符类之中的字符，其他字符都可以匹配。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("//字符串bbc news包含a、b、c以外的其他字符，所以返回true\n/[^abc]/.test('bbc news') // true\n\n//字符串bbc不包含a、b、c以外的其他字符，所以返回false\n/[^abc]/.test('bcc')\n")])])]),t("p",[t("strong",[a._v("注意：如果方括号内没有其他字符，即只有"),t("code",[a._v("[^]")]),a._v("，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（"),t("code",[a._v(".")]),a._v("）是不包括换行符的。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var s = 'Please yes\\nmake my day!';\n\ns.match(/yes.*day/) // null\ns.match(/yes[^]*day/) // [ 'yes\\nmake my day']\n")])])]),t("p",[t("strong",[a._v("注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/[a^b]/.test('ccc^')// true\n")])])]),t("h4",{attrs:{id:"方括号内的连字符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方括号内的连字符"}},[a._v("#")]),a._v(" 方括号内的连字符（"),t("code",[a._v("-")]),a._v("）")]),a._v(" "),t("p",[t("code",[a._v("-")]),a._v(" 在方括号外匹配普通连字符号，但是在方括号内（不在开头），则表示字符的连续范围。比如，"),t("code",[a._v("[abc]")]),a._v(" 可以写成 "),t("code",[a._v("[a-c]")]),a._v("，"),t("code",[a._v("[0123456789]")]),a._v(" 可以写成 "),t("code",[a._v("[0-9]")]),a._v("，同理"),t("code",[a._v("[A-Z]")]),a._v("表示 26 个大写字母。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/a-z/.test('b') // false\n/[a-z]/.test('b') // true\n")])])]),t("p",[a._v("以下都是合法的字符类简写形式")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[0-9,]\n[0-9a-fA-F]\n[a-zA-Z0-9-] // 注意：最后一个 - ，只是代表普通连字符号\n[1-31] //注意：不代表1到31，只代表1到3\n")])])]),t("p",[a._v("连字符还可以用来指定 Unicode 字符的范围")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('var str = "\\u0130\\u0131\\u0132";\n/[\\u0128-\\uFFFF]/.test(str)\n// true\n')])])]),t("p",[t("strong",[a._v("注意：不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符")])]),a._v(" "),t("p",[a._v("最典型的例子就是"),t("code",[a._v("[A-z]")]),a._v("，表面上它是选中从大写的 A 到小写的 z 之间 52 个字母，但是由于在 ASCII 编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 由于反斜杠（’\\‘）的ASCII码在大写字母与小写字母之间，结果会被选中\n/[A-z]/.test('\\\\') // true\n")])])]),t("h5",{attrs:{id:"如果想让方括号中的连字符匹配一个普通的连字符-连字符必须放在字符组的开头-保证它是一个普通字符。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如果想让方括号中的连字符匹配一个普通的连字符-连字符必须放在字符组的开头-保证它是一个普通字符。"}},[a._v("#")]),a._v(" 如果想让方括号中的连字符匹配一个普通的连字符，连字符必须放在字符组的开头，保证它是一个普通字符。")]),a._v(" "),t("h4",{attrs:{id:"方括号内的其他需要转义的元字符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方括号内的其他需要转义的元字符"}},[a._v("#")]),a._v(" 方括号内的其他需要转义的元字符")]),a._v(" "),t("p",[a._v("需要转义的元字符，除了"),t("code",[a._v("\\")]),a._v(" 需要转义，不能直接写在方括号中外， "),t("code",[a._v(". + ? * { } / ( ) $ | [ ]")]),a._v("在方括号内只是匹配普通字符")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/[.+?*{}/()$|]/.test('*') // true\n")])])]),t("h3",{attrs:{id:"组匹配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组匹配"}},[a._v("#")]),a._v(" 组匹配")]),a._v(" "),t("p",[a._v("组匹配相关的有分组字符、非捕获分组、引用字符")]),a._v(" "),t("h4",{attrs:{id:"分组字符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分组字符"}},[a._v("#")]),a._v(" 分组字符")]),a._v(" "),t("p",[a._v("正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。")]),a._v(" "),t("h5",{attrs:{id:"可通过-、-、-和-竖线-等符号修饰"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可通过-、-、-和-竖线-等符号修饰"}},[a._v("#")]),a._v(" 可通过 "),t("code",[a._v("*")]),a._v("、"),t("code",[a._v("+")]),a._v("、"),t("code",[a._v("?")]),a._v(" 和 竖线"),t("code",[a._v("|")]),a._v(" 等符号修饰")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/hi+/.exec('hihi') // 只能匹配 'hi'\n/(hi)+/.exec('hihi') // 可以匹配 'hihi'\n")])])]),t("h5",{attrs:{id:"可以进行分组捕获"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可以进行分组捕获"}},[a._v("#")]),a._v(" 可以进行分组捕获")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 正则表达式/(.)b(.)/一共使用两个括号，第一个括号捕获a，第二个括号捕获c。\n'abcabc'.match(/(.)b(.)/) // // ['abc', 'a', 'c']\n")])])]),t("p",[t("strong",[a._v("注意：使用分组捕获时，不宜同时使用 "),t("code",[a._v("g")]),a._v(" 修饰符，否则 "),t("code",[a._v("match")]),a._v(" 方法不会捕获分组的内容。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("'abcabc'.match(/(.)b(.)/g) // ['abc', 'abc']\n")])])]),t("p",[a._v("上面代码使用带 "),t("code",[a._v("g")]),a._v(" 修饰符的正则表达式，结果 "),t("code",[a._v("match")]),a._v(" 方法只捕获了匹配整个表达式的部分。这时必须使用正则表达式的 "),t("code",[a._v("exec")]),a._v(" 方法，配合循环，才能读到每一轮匹配的组捕获。")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" str "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'abcabc'")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" reg "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("(.)b(.)")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-flags"}},[a._v("g")])]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("while")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" result "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" reg"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("exec")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("str"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!")]),a._v("result"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("break")]),a._v("\n  console"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("result"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v('// ["abc", "a", "c"]')]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v('// ["abc", "a", "c"]')]),a._v("\n")])])]),t("h5",{attrs:{id:"可以跟引用字符配合使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可以跟引用字符配合使用"}},[a._v("#")]),a._v(" 可以跟引用字符配合使用")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('/(.)b(.)\\1b\\2/.test("abcabc")\n')])])]),t("p",[a._v("上面的代码中，\\1 表示第一个括号匹配的内容（即 a），\\2 表示第二个括号匹配的内容（即 c）")]),a._v(" "),t("h5",{attrs:{id:"非捕获分组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#非捕获分组"}},[a._v("#")]),a._v(" 非捕获分组")]),a._v(" "),t("p",[t("code",[a._v("(?:x)")]),a._v(" 称为非捕获组（Non-capturing group），表示不在捕获分组返回该组匹配的内容，即匹配的捕获分组的结果中不计入该分组的数据。")]),a._v(" "),t("p",[a._v("非捕获组的作用可能就是需要分组匹配，但是不需要在捕获分组中展示出来的情况。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的捕获分组的结果中没有第一个括号，只有第二个括号匹配的内容。\n'abc'.match(/(?:.)b(.)/); //\n")])])]),t("p",[t("strong",[a._v("注意：非捕获分组是不计入引用字符的编码的")])]),a._v(" "),t("h5",{attrs:{id:"引用字符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用字符"}},[a._v("#")]),a._v(" 引用字符")]),a._v(" "),t("p",[a._v("正则表达式内部，还可以用 "),t("code",[a._v("\\n")]),a._v(" 引用括号匹配的内容，n 是从 1 开始的自然数，表示对应顺序的括号。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// \\1表示第一个括号匹配的内容（即a），\\2表示第二个括号匹配的内容（即c）\n/(.)b(.)\\1b\\2/.test(\"abcabc\") // true\n\n// 引用字符的顺序可以按照实际情况调整\n/y(..)(.)\\2\\1/.test('yabccab') // true\n\n// 括号还可以嵌套，\\1指向外层括号，\\2指向内层括号\n/y((..)\\2)\\1/.test('yabababab') // true\n")])])]),t("h5",{attrs:{id:"具名分组-es2018"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#具名分组-es2018"}},[a._v("#")]),a._v(" 具名分组（ES2018）")]),a._v(" "),t("p",[a._v("ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。")]),a._v(" "),t("p",[a._v("语法是：“具名组匹配” 在圆括号内部，模式的头部添加 “问号 + 尖括号 + 组名”，例如 "),t("code",[a._v("?<year>")])]),a._v(" "),t("ul",[t("li",[a._v("捕获分组的改变")])]),a._v(" "),t("p",[a._v("组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如 "),t("code",[a._v("matchObj[1]")]),a._v("）引用，要是组的顺序变了，引用的时候就必须修改序号。")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("RE_DATE")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("(\\d{4})-(\\d{2})-(\\d{2})")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")])]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" matchObj "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("RE_DATE")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("exec")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'1999-12-31'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" year "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" matchObj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 1999")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" month "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" matchObj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 12")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" day "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" matchObj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 31")]),a._v("\n")])])]),t("p",[a._v("具名组匹配可以在 "),t("code",[a._v("exec")]),a._v(" 方法返回结果的 "),t("code",[a._v("groups")]),a._v(" 属性上引用该组名。同时，数字序号（"),t("code",[a._v("matchObj[1]")]),a._v("）依然有效。")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("RE_DATE")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")])]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" matchObj "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("RE_DATE")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("exec")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'1999-12-31'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" year "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" matchObj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("groups"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("year "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v('// "1999"')]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" month "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" matchObj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("groups"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("month "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v('// "12"')]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" day "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" matchObj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("groups"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("day "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v('// "31"')]),a._v("\n")])])]),t("p",[a._v("具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。")]),a._v(" "),t("p",[a._v("如果具名组没有匹配，那么对应的 "),t("code",[a._v("groups")]),a._v(" 对象属性会是 "),t("code",[a._v("undefined")]),a._v("。")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("RE_OPT_A")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("^(?<as>a+)?$")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")])]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" matchObj "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("RE_OPT_A")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("exec")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("''")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\nmatchObj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("groups"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("as "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// undefined")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'as'")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("in")]),a._v(" matchObj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("groups "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// true")]),a._v("\n")])])]),t("p",[a._v("上面代码中，具名组 as 没有找到匹配，那么 matchObj.groups.as 属性值就是 undefined，并且 as 这个键名在 groups 是始终存在的。")]),a._v(" "),t("ul",[t("li",[a._v("引用字符的改变")])]),a._v(" "),t("p",[a._v("具名组匹配的引用字符的语法是 "),t("code",[a._v("\\k")]),a._v("开始，后面添加“尖括号 + 组名”，例如 "),t("code",[a._v("\\k<first>")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/(.)b(.)\\1b\\2/.test(\"abcabc\") // true\n/(?<first>.)b(?<last>.)\\k<first>b\\k<last>/.test(\"abcabc\") // true\n\n\n// 引用字符的顺序可以按照实际情况调整\n/y(..)(.)\\2\\1/.test('yabccab') // true\n/y(?<first>..)(?<last>.)\\k<last>\\k<first>/.test('yabccab') // true\n")])])]),t("ul",[t("li",[a._v("replace 方法的改变")])]),a._v(" "),t("p",[a._v("字符串替换时，使用"),t("code",[a._v("$<组名>")]),a._v("引用具名组。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let re = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u;\n\n'2015-01-02'.replace(re, '$<day>/$<month>/$<year>')\n// '02/01/2015'\n")])])]),t("p",[a._v("replace 方法的第二个参数也可以是函数，具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("'2015-01-02'.replace(re, (\n   matched, // 整个匹配结果 2015-01-02\n   capture1, // 第一个组匹配 2015\n   capture2, // 第二个组匹配 01\n   capture3, // 第三个组匹配 02\n   position, // 匹配开始的位置 0\n   S, // 原字符串 2015-01-02\n   groups // 具名组构成的一个对象 {year, month, day}\n ) => {\n let {day, month, year} = groups;\n return `${day}/${month}/${year}`;\n});\n")])])]),t("h5",{attrs:{id:"实际应用的例子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实际应用的例子"}},[a._v("#")]),a._v(" 实际应用的例子")]),a._v(" "),t("ol",[t("li",[a._v("匹配网页标签")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let reg = /<([^>]+)>[^<]*<\\/\\1>/\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[a._v("捕获带有属性的标签")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let reg = /<(\\w+)\\s([^>]*)>(.*?)<\\/\\1>/\n")])])]),t("ol",{attrs:{start:"3"}},[t("li",[a._v("匹配网址并且捕获 host")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let reg = /^(https?:\\/\\/)?([\\w-]+\\.)+[\\w-]+/\n")])])]),t("h3",{attrs:{id:"修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#修饰符"}},[a._v("#")]),a._v(" 修饰符")]),a._v(" "),t("p",[a._v("修饰符（modifier）表示模式的附加规则，放在正则表达式的最尾部。")]),a._v(" "),t("p",[t("strong",[a._v("修饰符可以单个使用，也可以多个一起使用。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 单个修饰符\nvar regex = /test/i;\n\n// 多个修饰符\nvar regex = /test/ig;\n")])])]),t("h4",{attrs:{id:"g-修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#g-修饰符"}},[a._v("#")]),a._v(" "),t("code",[a._v("g")]),a._v(" 修饰符")]),a._v(" "),t("p",[t("code",[a._v("g")]),a._v(" 修饰符表示全局匹配（global）。默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。")]),a._v(" "),t("p",[a._v("以下代码不含 "),t("code",[a._v("g")]),a._v(" 修饰符，每次都是从字符串头部开始匹配。所以，连续做了三次匹配，都返回 true。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var regex = /b/;\nvar str = 'abba';\n\nregex.test(str); // true\nregex.test(str); // true\nregex.test(str); // true\n")])])]),t("p",[a._v("以下正则模式含有 "),t("code",[a._v("g")]),a._v(" 修饰符，"),t("strong",[a._v("每次都是从上一次匹配成功处，开始向后匹配")]),a._v("。因为字符串 abba 只有两个 b，所以前两次匹配结果为 true，第三次匹配结果为 false。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var regex = /b/g;\nvar str = 'abba';\n\nregex.test(str); // true\nregex.test(str); // true\nregex.test(str); // false\n")])])]),t("h4",{attrs:{id:"i-修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#i-修饰符"}},[a._v("#")]),a._v(" "),t("code",[a._v("i")]),a._v(" 修饰符")]),a._v(" "),t("p",[t("code",[a._v("i")]),a._v(" 修饰符表示忽略大小写（ignorecase）。")]),a._v(" "),t("h4",{attrs:{id:"m-修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#m-修饰符"}},[a._v("#")]),a._v(" "),t("code",[a._v("m")]),a._v(" 修饰符")]),a._v(" "),t("p",[t("code",[a._v("m")]),a._v(" 修饰符表示多行模式（multiline），会修改 "),t("code",[a._v("^")]),a._v(" 和 "),t("code",[a._v("$")]),a._v(" 的行为。")]),a._v(" "),t("p",[a._v("默认情况下（即不加 "),t("code",[a._v("m")]),a._v(" 修饰符时），"),t("code",[a._v("^")]),a._v(" 和 "),t("code",[a._v("$")]),a._v(" 匹配字符串的"),t("strong",[a._v("开始处和结尾处")]),a._v("，加上 "),t("code",[a._v("m")]),a._v(" 修饰符以后，"),t("code",[a._v("^")]),a._v(" 和 "),t("code",[a._v("$")]),a._v(" "),t("strong",[a._v("还会匹配行首和行尾")]),a._v("，即 "),t("code",[a._v("^")]),a._v(" 和 "),t("code",[a._v("$")]),a._v(" 会识别换行符（ "),t("code",[a._v("\\n")]),a._v(" ）。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/world$/.test('hello world\\n') // false\n/world$/m.test('hello world\\n') // true\n/^b/m.test('a\\nb') // true 加上m修饰符以后，换行符\\n也会被认为是一行的开始\n")])])]),t("h4",{attrs:{id:"u-修饰符-es6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#u-修饰符-es6"}},[a._v("#")]),a._v(" "),t("code",[a._v("u")]),a._v(" 修饰符（ES6）")]),a._v(" "),t("p",[a._v("含义为“Unicode 模式”，用来正确处理大于\\uFFFF 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。")]),a._v(" "),t("h5",{attrs:{id:"点字符-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#点字符-2"}},[a._v("#")]),a._v(" 点字符")]),a._v(" "),t("p",[a._v("点（"),t("code",[a._v(".")]),a._v("）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于 "),t("code",[a._v("0xFFFF")]),a._v(" 的 Unicode 字符，点字符不能识别，必须加上 "),t("code",[a._v("u")]),a._v(" 修饰符。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var s = '𠮷';\n\n/^.$/.test(s) // false\n/^.$/u.test(s) // true\n")])])]),t("h5",{attrs:{id:"unicode-字符表示法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#unicode-字符表示法"}},[a._v("#")]),a._v(" Unicode 字符表示法")]),a._v(" "),t("p",[a._v("ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上 "),t("code",[a._v("u")]),a._v(" 修饰符，才能识别当中的大括号，否则会被解读为量词。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/\\u{61}/.test('a') // false\n/\\u{61}/u.test('a') // true\n/\\u{20BB7}/u.test('𠮷') // true\n")])])]),t("p",[a._v("上面代码表示，如果不加 "),t("code",[a._v("u")]),a._v(" 修饰符，正则表达式无法识别 "),t("code",[a._v("\\u{61}")]),a._v(" 这种表示法，只会认为这匹配 61 个连续的 u。")]),a._v(" "),t("h5",{attrs:{id:"预定义模式-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#预定义模式-2"}},[a._v("#")]),a._v(" 预定义模式")]),a._v(" "),t("p",[t("code",[a._v("u")]),a._v(" 修饰符也影响到预定义模式，能否正确识别码点大于"),t("code",[a._v("0xFFFF")]),a._v("的 Unicode 字符。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/^\\S$/.test('𠮷') // false\n/^\\S$/u.test('𠮷') // true\n")])])]),t("p",[a._v("上面代码的 "),t("code",[a._v("\\S")]),a._v(" 是预定义模式，匹配所有非空白字符。只有加了 "),t("code",[a._v("u")]),a._v(" 修饰符，它才能正确匹配码点大于 "),t("code",[a._v("0xFFFF")]),a._v(" 的 Unicode 字符。")]),a._v(" "),t("p",[a._v("利用这一点，可以写出一个正确返回字符串长度的函数。")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("codePointLength")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("text")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" result "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" text"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("match")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("[\\s\\S]")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-flags"}},[a._v("gu")])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" result "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),a._v(" result"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("length "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" s "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'𠮷𠮷'")]),a._v("\n\ns"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("length "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 4")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("codePointLength")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("s"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 2")]),a._v("\n")])])]),t("h5",{attrs:{id:"量词-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#量词-2"}},[a._v("#")]),a._v(" 量词")]),a._v(" "),t("p",[a._v("使用 u 修饰符后，所有量词都会正确识别码点大于 0xFFFF 的 Unicode 字符。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/a{2}/.test('aa') // true\n/a{2}/u.test('aa') // true\n/𠮷{2}/.test('𠮷𠮷') // false\n/𠮷{2}/u.test('𠮷𠮷') // true\n")])])]),t("h5",{attrs:{id:"转义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#转义"}},[a._v("#")]),a._v(" 转义")]),a._v(" "),t("p",[a._v("没有 u 修饰符的情况下，正则中没有定义的转义（如逗号的转义,）无效，而在 u 模式会报错。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/\\,/ // 输出 /\\,/\n/\\,/u // 报错\n")])])]),t("h4",{attrs:{id:"y-修饰符-es6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#y-修饰符-es6"}},[a._v("#")]),a._v(" "),t("code",[a._v("y")]),a._v(" 修饰符（ES6）")]),a._v(" "),t("p",[a._v("也叫做“粘连”（sticky）修饰符。")]),a._v(" "),t("p",[t("code",[a._v("y")]),a._v(" 修饰符的作用与 "),t("code",[a._v("g")]),a._v(" 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，"),t("code",[a._v("g")]),a._v(" 修饰符只要剩余位置中存在匹配就可，而 "),t("code",[a._v("y")]),a._v(" 修饰符"),t("strong",[a._v("确保匹配必须从剩余的第一个位置开始")]),a._v("，这也就是“粘连”的涵义。")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" s "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'aaa_aa_a'")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" r1 "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("a+")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-flags"}},[a._v("g")])]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" r2 "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("a+")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-flags"}},[a._v("y")])]),a._v("\n\nr1"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("exec")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("s"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v('// ["aaa"]')]),a._v("\nr2"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("exec")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("s"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v('// ["aaa"]')]),a._v("\n\nr1"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("exec")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("s"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v('// ["aa"]')]),a._v("\nr2"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("exec")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("s"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// null y修饰符要求匹配必须从头部开始，所以返回null")]),a._v("\n")])])]),t("h5",{attrs:{id:"实际上-y-修饰符号隐含了头部匹配的标志-。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实际上-y-修饰符号隐含了头部匹配的标志-。"}},[a._v("#")]),a._v(" 实际上，"),t("code",[a._v("y")]),a._v(" 修饰符号隐含了头部匹配的标志 "),t("code",[a._v("^")]),a._v("。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/b/y.exec('aba') // null\n")])])]),t("h5",{attrs:{id:"单单一个-y-修饰符对-match-方法-只能返回第一个匹配-必须与-g-修饰符联用-才能返回所有匹配。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单单一个-y-修饰符对-match-方法-只能返回第一个匹配-必须与-g-修饰符联用-才能返回所有匹配。"}},[a._v("#")]),a._v(" 单单一个 "),t("code",[a._v("y")]),a._v(" 修饰符对 "),t("code",[a._v("match")]),a._v(" 方法，只能返回第一个匹配，必须与 "),t("code",[a._v("g")]),a._v(" 修饰符联用，才能返回所有匹配。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('\'a1a2a3\'.match(/a\\d/y) // ["a1"]\n\'a1a2a3\'.match(/a\\d/gy) // ["a1", "a2", "a3"]\n')])])]),t("h4",{attrs:{id:"s-修饰符-dotall-模式-es2018"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#s-修饰符-dotall-模式-es2018"}},[a._v("#")]),a._v(" "),t("code",[a._v("s")]),a._v(" 修饰符："),t("code",[a._v("dotAll")]),a._v(" 模式（ES2018）")]),a._v(" "),t("p",[t("code",[a._v("dotAll")]),a._v(" 模式，即点（dot）代表一切字符。")]),a._v(" "),t("p",[a._v("正则表达式中，点（"),t("code",[a._v(".")]),a._v("）是一个特殊字符，代表任意的单个字符，")]),a._v(" "),t("p",[a._v("但是有两个例外:")]),a._v(" "),t("ul",[t("li",[a._v("一个是四个字节的 UTF-16 字符，这个可以用 "),t("code",[a._v("u")]),a._v(" 修饰符解决；")]),a._v(" "),t("li",[a._v("另一个是行终止符（line terminator character）。"),t("strong",[a._v("这个就需要 "),t("code",[a._v("s")]),a._v(" 修饰符解决")])])]),a._v(" "),t("p",[a._v("所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。")]),a._v(" "),t("ul",[t("li",[a._v("U+000A 换行符（"),t("code",[a._v("\\n")]),a._v("）")]),a._v(" "),t("li",[a._v("U+000D 回车符（"),t("code",[a._v("\\r")]),a._v("）")]),a._v(" "),t("li",[a._v("U+2028 行分隔符（line separator）")]),a._v(" "),t("li",[a._v("U+2029 段分隔符（paragraph separator）")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/foo.bar/.test('foo\\nbar') // false\n")])])]),t("p",[a._v("上面代码中，因为 "),t("code",[a._v(".")]),a._v(" 不匹配 "),t("code",[a._v("\\n")]),a._v("，所以正则表达式返回 false。")]),a._v(" "),t("p",[a._v("但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/foo[^]bar/.test('foo\\nbar') // true\n")])])]),t("p",[a._v("这种解决方案毕竟不太符合直觉，ES2018 引入 "),t("code",[a._v("s")]),a._v(" 修饰符，使得 "),t("code",[a._v(".")]),a._v(" 可以匹配任意单个字符。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/foo.bar/s.test('foo\\nbar') // true\n")])])]),t("h5",{attrs:{id:"s-修饰符和多行修饰符-m-不冲突-两者一起使用的情况下-匹配所有字符-而-和-匹配每一行的行首和行尾。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#s-修饰符和多行修饰符-m-不冲突-两者一起使用的情况下-匹配所有字符-而-和-匹配每一行的行首和行尾。"}},[a._v("#")]),a._v(" "),t("code",[a._v("s")]),a._v(" 修饰符和多行修饰符 "),t("code",[a._v("m")]),a._v(" 不冲突，两者一起使用的情况下，"),t("code",[a._v(".")]),a._v(" 匹配所有字符，而 "),t("code",[a._v("^")]),a._v("和"),t("code",[a._v("$")]),a._v(" 匹配每一行的行首和行尾。")]),a._v(" "),t("h4",{attrs:{id:"d-修饰符-正则匹配索引"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#d-修饰符-正则匹配索引"}},[a._v("#")]),a._v(" "),t("code",[a._v("d")]),a._v(" 修饰符：正则匹配索引")]),a._v(" "),t("p",[a._v("ES2022 新增了 d 修饰符，这个修饰符可以让 exec()、match()的返回结果添加 indices 属性，在该属性上面可以拿到匹配的开始位置和结束位置。")]),a._v(" "),t("p",[a._v("注意，开始位置包含在匹配结果之中，相当于匹配结果的第一个字符的位置。但是，结束位置不包含在匹配结果之中，是匹配结果的下一个字符。")]),a._v(" "),t("p",[a._v("如果正则表达式包含组匹配，那么 indices 属性对应的数组就会包含多个成员，提供每个组匹配的开始位置和结束位置。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const text = 'zabbcdef';\nconst re = /ab+(cd)/d;\nconst result = re.exec(text);\n\nresult.indices // [ [ 1, 6 ], [ 4, 6 ] ]\n")])])]),t("p",[a._v("上面例子中，正则表达式 re 包含一个组匹配(cd)，那么 "),t("code",[a._v("indices")]),a._v(" 属性数组就有两个成员，第一个成员是整个匹配结果（abbcd）的开始位置和结束位置，第二个成员是组匹配（cd）的开始位置和结束位置。")]),a._v(" "),t("p",[a._v("如果正则表达式包含具名组匹配，indices 属性数组还会有一个 groups 属性。该属性是一个对象，可以从该对象获取具名组匹配的开始位置和结束位置。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const text = 'zabbcdef';\nconst re = /ab+(?<Z>cd)/d;\nconst result = re.exec(text);\n\nresult.indices.groups // { Z: [ 4, 6 ] }\n")])])]),t("p",[a._v("面例子中，exec()方法返回结果的 indices.groups 属性是一个对象，提供具名组匹配 Z 的开始位置和结束位置。")]),a._v(" "),t("p",[a._v("如果获取组匹配不成功，indices 属性数组的对应成员则为 undefined，indices.groups 属性对象的对应成员也是 undefined。")]),a._v(" "),t("h3",{attrs:{id:"特殊字符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特殊字符"}},[a._v("#")]),a._v(" 特殊字符")]),a._v(" "),t("p",[a._v("正则表达式对一些不能打印的特殊字符，提供了表达方法。")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("\\cX")]),a._v("：表示 "),t("code",[a._v("Ctrl-[X]")]),a._v("，其中的 X 是 A-Z 之中任一个英文字母，用来匹配控制字符。")]),a._v(" "),t("li",[t("code",[a._v("[\\b]")]),a._v("：匹配退格键("),t("code",[a._v("\\u0008")]),a._v(")，不要与 "),t("code",[a._v("\\b")]),a._v(" 混淆")]),a._v(" "),t("li",[t("code",[a._v("\\n")]),a._v("：匹配换行键（\\u000A）")]),a._v(" "),t("li",[t("code",[a._v("\\r")]),a._v("：匹配回车键（\\u000D）")]),a._v(" "),t("li",[t("code",[a._v("\\t")]),a._v("：匹配制表符 tab（\\u0009）")]),a._v(" "),t("li",[t("code",[a._v("\\v")]),a._v("：匹配垂直制表符（\\u000B）")]),a._v(" "),t("li",[t("code",[a._v("\\f")]),a._v("：匹配换页符（\\u000C）")]),a._v(" "),t("li",[t("code",[a._v("\\0")]),a._v("：匹配 null 字符（\\u0000）")]),a._v(" "),t("li",[t("code",[a._v("\\xhh")]),a._v("：匹配一个以两位十六进制数（\\x00-\\xFF）表示的字符")]),a._v(" "),t("li",[t("code",[a._v("\\uhhhh")]),a._v("：匹配一个以四位十六进制数（\\u0000-\\uFFFF）表示的 Unicode 字符")])]),a._v(" "),t("p",[a._v("其中有一些可以进行替代：")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("\\x0A")]),a._v("等价于 "),t("code",[a._v("\\n")])]),a._v(" "),t("li",[t("code",[a._v("\\u0009")]),a._v("等价于 "),t("code",[a._v("\\t")])]),a._v(" "),t("li",[t("code",[a._v("\\cJ")]),a._v(" 等价于 "),t("code",[a._v("\\n")])])]),a._v(" "),t("h2",{attrs:{id:"属性方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#属性方法"}},[a._v("#")]),a._v(" 属性方法")]),a._v(" "),t("h3",{attrs:{id:"regexp-实例方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#regexp-实例方法"}},[a._v("#")]),a._v(" RegExp 实例方法")]),a._v(" "),t("h4",{attrs:{id:"regexp-prototype-test"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#regexp-prototype-test"}},[a._v("#")]),a._v(" RegExp.prototype.test()")]),a._v(" "),t("p",[a._v("正则实例对象的 "),t("code",[a._v("test")]),a._v(" 方法返回一个布尔值，表示当前模式是否能匹配参数字符串。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/cat/.test('cats and dogs') // true\n")])])]),t("h5",{attrs:{id:"正则表达式带有-g-修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式带有-g-修饰符"}},[a._v("#")]),a._v(" 正则表达式带有 "),t("code",[a._v("g")]),a._v(" 修饰符")]),a._v(" "),t("p",[a._v("如果正则表达式带有 g 修饰符，则每一次 test 方法都从上一次结束的位置开始向后匹配。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var r = /x/g;\nvar s = '_x_x';\n\nr.lastIndex // 0\nr.test(s) // true\n\nr.lastIndex // 2\nr.test(s) // true\n\nr.lastIndex // 4\nr.test(s) // false\n")])])]),t("p",[a._v("带有 "),t("code",[a._v("g")]),a._v(" 修饰符时，可以通过正则对象的 "),t("code",[a._v("lastIndex")]),a._v(" 属性指定开始搜索的位置。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var r = /x/g;\nvar s = '_x_x';\n\nr.lastIndex = 4;\nr.test(s) // false lastIndex 属性重置为 0\n\nr.lastIndex // 0\nr.test(s) // true\n")])])]),t("p",[t("strong",[a._v("注意：带有 "),t("code",[a._v("g")]),a._v(" 修饰符时，正则表达式内部会记住上一次的 "),t("code",[a._v("lastIndex")]),a._v(" 属性，这时不应该更换所要匹配的字符串，否则会有一些难以察觉的错误。")])]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" r "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("bb")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-flags"}},[a._v("g")])]),a._v("\nr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("test")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'bb'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// true")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 由于正则表达式r是从上一次的lastIndex位置开始匹配，导致第二次执行test方法时出现预期以外的结果")]),a._v("\nr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("test")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'-bb-'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// false")]),a._v("\n")])])]),t("p",[t("strong",[a._v("注意：lastIndex 属性只对同一个正则表达式有效")]),a._v("，所以下面这样写是错误的。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 下面代码会导致无限循环，因为while循环的每次匹配条件都是一个新的正则表达式，导致lastIndex属性总是等于0。\nvar count = 0;\nwhile (/a/g.test('babaa')) count++;\n\n// 如果需要达到预期的效果，可以使用变量存放正则对象\nvar count = 0;\nvar reg = /a/g\nwhile (reg.test('babaa')) count++;\n")])])]),t("h5",{attrs:{id:"如果正则模式是一个空字符串-则匹配所有字符串。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如果正则模式是一个空字符串-则匹配所有字符串。"}},[a._v("#")]),a._v(" 如果正则模式是一个空字符串，则匹配所有字符串。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("new RegExp('').test('abc')\n")])])]),t("p",[a._v("如果想使用正则表达式字面量模式匹配所有字符串，不能用 "),t("code",[a._v("//")]),a._v("，这个是错误的，需要使用 "),t("code",[a._v("/(?:)/")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/(?:)/.test('abc')\n\n// 因为\nnew RegExp('').toString() // '/(?:)/'\n")])])]),t("p",[a._v("另外 "),t("code",[a._v("/^$/")]),a._v(" 可以匹配空字符串")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/^$/.test('')\n")])])]),t("h4",{attrs:{id:"regexp-prototype-exec"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#regexp-prototype-exec"}},[a._v("#")]),a._v(" RegExp.prototype.exec()")]),a._v(" "),t("p",[a._v("正则实例对象的 "),t("code",[a._v("exec")]),a._v(" 方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回 "),t("code",[a._v("null")]),a._v("。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('var s = \'_x_x\';\nvar r1 = /x/;\nvar r2 = /y/;\n\nr1.exec(s) // ["x"] 其实返回的对象全部属性时这样的 0:"x" groups:undefined index:1 input:"_x_x" length: 1\nr2.exec(s) // null\n')])])]),t("p",[a._v("如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。\n第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的 length 属性等于组匹配的数量再加 1。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('var s = \'_x_x\';\nvar r = /_(x)/;\n\nr.exec(s) // ["_x", "x"] length 是 2\n')])])]),t("h5",{attrs:{id:"返回值中的-input-属性和-index-属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#返回值中的-input-属性和-index-属性"}},[a._v("#")]),a._v(" 返回值中的 "),t("code",[a._v("input")]),a._v(" 属性和 "),t("code",[a._v("index")]),a._v(" 属性")]),a._v(" "),t("p",[a._v("其实返回的数组全部属性时这样的 "),t("code",[a._v("['_x', 'x', index: 0, input: '_x_x', groups: undefined]")])]),a._v(" "),t("ul",[t("li",[t("code",[a._v("input")]),a._v("：整个原字符串。")]),a._v(" "),t("li",[t("code",[a._v("index")]),a._v("：整个模式匹配成功的开始位置（从 0 开始计数）。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('var r = /a(b+)a/;\nvar arr = r.exec(\'_abbba_aba_\');\n\narr // ["abbba", "bbb"]\n\narr.index // 1\narr.input // "_abbba_aba_"\n')])])]),t("h5",{attrs:{id:"如果正则表达式加上-g-修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如果正则表达式加上-g-修饰符"}},[a._v("#")]),a._v(" 如果正则表达式加上 "),t("code",[a._v("g")]),a._v(" 修饰符")]),a._v(" "),t("p",[a._v("如果正则表达式加上 "),t("code",[a._v("g")]),a._v(" 修饰符，则可以使用多次 "),t("code",[a._v("exec")]),a._v(" 方法，下一次搜索的位置从上一次匹配成功结束的位置开始。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var reg = /a/g;\nvar str = 'abc_abc_abc'\n\nwhile(true) {\n  var match = reg.exec(str);\n  if (!match) break;\n  console.log('#' + match.index + ':' + match[0]);\n}\n// #0:a\n// #4:a\n// #8:a\n")])])]),t("h3",{attrs:{id:"regexp-对象属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#regexp-对象属性"}},[a._v("#")]),a._v(" RegExp 对象属性")]),a._v(" "),t("h4",{attrs:{id:"source"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#source"}},[a._v("#")]),a._v(" source")]),a._v(" "),t("p",[a._v("只读字符串，包含正则表达式的文本。")]),a._v(" "),t("h4",{attrs:{id:"global"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#global"}},[a._v("#")]),a._v(" global")]),a._v(" "),t("p",[a._v("只读布尔值，是否带修饰符 "),t("code",[a._v("g")])]),a._v(" "),t("h4",{attrs:{id:"ignorecase"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ignorecase"}},[a._v("#")]),a._v(" ignoreCase")]),a._v(" "),t("p",[a._v("只读布尔值，是否带修饰符 "),t("code",[a._v("i")])]),a._v(" "),t("h4",{attrs:{id:"multiline"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#multiline"}},[a._v("#")]),a._v(" multiline")]),a._v(" "),t("p",[a._v("只读布尔值，是否带修饰符 "),t("code",[a._v("m")])]),a._v(" "),t("h4",{attrs:{id:"unicode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#unicode"}},[a._v("#")]),a._v(" unicode")]),a._v(" "),t("p",[a._v("ES6 新增，只读布尔值，表示是否设置了 u 修饰符。")]),a._v(" "),t("h4",{attrs:{id:"sticky"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sticky"}},[a._v("#")]),a._v(" sticky")]),a._v(" "),t("p",[a._v("ES6 新增，只读布尔值，表示是否设置了 u 修饰符。")]),a._v(" "),t("h4",{attrs:{id:"dotall"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dotall"}},[a._v("#")]),a._v(" dotall")]),a._v(" "),t("p",[a._v("返回一个布尔值，表示该正则表达式是否处在 dotAll 模式。")]),a._v(" "),t("h4",{attrs:{id:"flags"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#flags"}},[a._v("#")]),a._v(" flags")]),a._v(" "),t("p",[a._v("返回一个字符串，包含了已经设置的所有修饰符，按字母排序。")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" r "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("abc")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-flags"}},[a._v("gimuy")])]),a._v("\n\nr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("ignoreCase "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// true")]),a._v("\nr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("global "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// true")]),a._v("\nr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("multiline "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// true")]),a._v("\nr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("unicode "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// true")]),a._v("\nr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("sticky "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// true")]),a._v("\nr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("flags "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 'gimuy'")]),a._v("\n")])])]),t("h4",{attrs:{id:"lastindex"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lastindex"}},[a._v("#")]),a._v(" lastIndex")]),a._v(" "),t("p",[a._v("可读写整数，如果带 g 修饰符，这个属性储存在整个字符串中下一次检索开始的位置，这个属性会被 "),t("code",[a._v("exec()")]),a._v(" 和 "),t("code",[a._v("test()")]),a._v(" 方法用到。")]),a._v(" "),t("p",[a._v("当调用 "),t("code",[a._v("exec()")]),a._v(" 或 "),t("code",[a._v("test()")]),a._v(" 的正则表达式具有修饰符 "),t("code",[a._v("g")]),a._v(" 时，它将把当前正则表达式对象的 "),t("code",[a._v("lastIndex")]),a._v(" 属性设置为紧挨着匹配子串的字符位置。如果没发现任何匹配结果，"),t("code",[a._v("lastIndex")]),a._v(" 将重置为 "),t("code",[a._v("0")]),a._v("。")]),a._v(" "),t("h3",{attrs:{id:"字符串实例方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串实例方法"}},[a._v("#")]),a._v(" 字符串实例方法")]),a._v(" "),t("h4",{attrs:{id:"string-prototype-match"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string-prototype-match"}},[a._v("#")]),a._v(" String.prototype.match()")]),a._v(" "),t("p",[a._v("对字符串进行正则匹配，匹配成功返回一个数组，成员是所有匹配的子字符串，匹配失败返回 null。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var s = '_x_x';\nvar r1 = /x/;\nvar r2 = /y/;\n\ns.match(r1) // [\"x\"]\ns.match(r2) // null\n")])])]),t("h5",{attrs:{id:"如果正则表达式带有-g-修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如果正则表达式带有-g-修饰符"}},[a._v("#")]),a._v(" 如果正则表达式带有 g 修饰符")]),a._v(" "),t("p",[a._v("如果正则表达式带有 "),t("code",[a._v("g")]),a._v(" 修饰符，则该方法与正则对象的 "),t("code",[a._v("exec")]),a._v(" 方法行为不同，会一次性返回所有匹配成功的结果。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('var s = \'abba\';\nvar r = /a/g;\n\ns.match(r) // ["a", "a"]\nr.exec(s) // ["a"]\n')])])]),t("h5",{attrs:{id:"设置正则表达式的-lastindex-属性-对-match-方法无效-匹配总是从字符串的第一个字符开始"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设置正则表达式的-lastindex-属性-对-match-方法无效-匹配总是从字符串的第一个字符开始"}},[a._v("#")]),a._v(" 设置正则表达式的 "),t("code",[a._v("lastIndex")]),a._v(" 属性，对 "),t("code",[a._v("match")]),a._v(" 方法无效，匹配总是从字符串的第一个字符开始")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var r = /a|b/g;\nr.lastIndex = 7;\n'xaxb'.match(r) // ['a', 'b']\nr.lastIndex // 0\n")])])]),t("h4",{attrs:{id:"string-prototype-matchall"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string-prototype-matchall"}},[a._v("#")]),a._v(" String.prototype.matchAll()")]),a._v(" "),t("p",[a._v("ES2020 增加了 String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个迭代器（Iterator），而不是数组。")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" string "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'test1test2test3'")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" regex "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("t(e)(st(\\d?))")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-flags"}},[a._v("g")])]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("for")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" match "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("of")]),a._v(" string"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("matchAll")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("regex"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  console"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("match"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v('// ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]')]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v('// ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]')]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v('// ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]')]),a._v("\n")])])]),t("p",[a._v("上面代码中，由于 "),t("code",[a._v("string.matchAll(regex)")]),a._v(" 返回的是迭代器，所以可以用 "),t("code",[a._v("for...of")]),a._v(" 循环取出。相对于返回 "),t("code",[a._v("match()")]),a._v(" 数组，返回迭代器的好处在于，如果匹配结果是一个很大的数组，那么迭代器比较节省资源。")]),a._v(" "),t("p",[a._v("迭代器转为数组是非常简单的，使用"),t("code",[a._v("...")]),a._v("运算符和 "),t("code",[a._v("Array.from()")]),a._v("方法就可以了。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 转为数组的方法一\n[...string.matchAll(regex)]\n\n// 转为数组的方法二\nArray.from(string.matchAll(regex))\n")])])]),t("h4",{attrs:{id:"string-prototype-search"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string-prototype-search"}},[a._v("#")]),a._v(" String.prototype.search()")]),a._v(" "),t("p",[a._v("返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("'_x_x'.search(/x/) // 1\n")])])]),t("h4",{attrs:{id:"string-prototype-replace"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string-prototype-replace"}},[a._v("#")]),a._v(" String.prototype.replace()")]),a._v(" "),t("p",[a._v("字符串对象的 "),t("code",[a._v("replace")]),a._v(" 方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。")]),a._v(" "),t("h5",{attrs:{id:"正则表达式由-g-修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式由-g-修饰符"}},[a._v("#")]),a._v(" 正则表达式由 "),t("code",[a._v("g")]),a._v(" 修饰符")]),a._v(" "),t("p",[a._v("正则表达式如果不加 "),t("code",[a._v("g")]),a._v(" 修饰符，就替换第一个匹配成功的值，如果有替换所有匹配成功的值。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("'aaa'.replace('a', 'b') // \"baa\"\n'aaa'.replace(/a/, 'b') // \"baa\"\n'aaa'.replace(/a/g, 'b') // \"bbb\"\n")])])]),t("h5",{attrs:{id:"第二个参数可以使用美元符号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第二个参数可以使用美元符号"}},[a._v("#")]),a._v(" 第二个参数可以使用美元符号 "),t("code",[a._v("$")])]),a._v(" "),t("p",[t("code",[a._v("replace")]),a._v(" 方法的第二个参数可以使用美元符号 "),t("code",[a._v("$")]),a._v("，用来指代所替换的内容。")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("$&")]),a._v("：匹配的子字符串。")]),a._v(" "),t("li",[a._v("$`：匹配结果前面的文本。")]),a._v(" "),t("li",[t("code",[a._v("$'")]),a._v("：匹配结果后面的文本。")]),a._v(" "),t("li",[t("code",[a._v("$n")]),a._v("：匹配成功的第 n 组内容，n 是从 1 开始的自然数。")]),a._v(" "),t("li",[t("code",[a._v("$$")]),a._v("：指代美元符号 "),t("code",[a._v("$")]),a._v("。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("'hello world'.replace(/(\\w+)\\s(\\w+)/, '$2 $1')\n// \"world hello\"\n\n'abc'.replace('b', '[$`-$&-$\\'$$]')\n// 'a[a-b-c$]c'\n")])])]),t("h5",{attrs:{id:"第二个参数还可以是一个函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第二个参数还可以是一个函数"}},[a._v("#")]),a._v(" 第二个参数还可以是一个函数")]),a._v(" "),t("p",[t("code",[a._v("replace")]),a._v(" 方法的第二个参数还可以是一个函数，"),t("strong",[a._v("将每一个匹配内容替换为函数返回值")])]),a._v(" "),t("p",[a._v("作为 "),t("code",[a._v("replace")]),a._v(" 方法第二个参数的替换函数，可以接受多个参数。")]),a._v(" "),t("ul",[t("li",[a._v("第一个参数是捕捉到的内容")]),a._v(" "),t("li",[a._v("第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。")])]),a._v(" "),t("p",[a._v("此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("'6 and 10'\n'3 and 5'.replace(/[0-9]+/g, function (...args) {\n  console.log(args)\n  return 2 * args[0];\n})\n//'6 and 10'\n// ['3', 0, '3 and 5'] 注意倒数第二个和倒数第一个参数\n// ['5', 6, '3 and 5']\n")])])]),t("h5",{attrs:{id:"replace-应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#replace-应用"}},[a._v("#")]),a._v(" replace 应用")]),a._v(" "),t("ol",[t("li",[a._v("将价格插入到模板中")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var prices = {\n  'p1': '$1.99',\n  'p2': '$9.99',\n  'p3': '$5.00'\n};\n\nvar template = '<span id=\"p1\"></span>'\n  + '<span id=\"p2\"></span>'\n  + '<span id=\"p3\"></span>';\n\ntemplate.replace(\n  /(<span id=\")(.*?)(\">)(<\\/span>)/g,\n  function(match, $1, $2, $3, $4){\n    return $1 + $2 + $3 + prices[$2] + $4;\n  }\n);\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[a._v("消除字符串首尾两端的空格")])]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("customTrim")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("str")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 正则表达式：匹配字符串开头和结尾的空白字符")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// ^\\s+ 匹配字符串开头的一个或多个空白字符")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// \\s+$ 匹配字符串结尾的一个或多个空白字符")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" regExp "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("^\\s+|\\s+$")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-flags"}},[a._v("g")])]),a._v("\n\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 使用 replace 方法和正则表达式移除字符串两端的空白字符")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" str"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("replace")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("regExp"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("''")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("h4",{attrs:{id:"string-prototype-split"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string-prototype-split"}},[a._v("#")]),a._v(" String.prototype.split()")]),a._v(" "),t("p",[a._v("字符串对象的 split 方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 非正则分隔\n'a,  b,c, d'.split(',')\n// [ 'a', '  b', 'c', ' d' ]\n\n// 正则分隔，去除多余的空格\n'a,  b,c, d'.split(/, */)\n// [ 'a', 'b', 'c', 'd' ]\n\n// 指定返回数组的最大成员\n'a,  b,c, d'.split(/, */, 2)\n[ 'a', 'b' ]\n")])])]),t("h5",{attrs:{id:"贪婪匹配下的分割"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#贪婪匹配下的分割"}},[a._v("#")]),a._v(" 贪婪匹配下的分割")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 例一\n'aaa*a*'.split(/a*/)\n// [ '', '*', '*' ]\n\n// 例二\n'aaa**a*'.split(/a*/)\n// [\"\", \"*\", \"*\", \"*\"]\n")])])]),t("p",[a._v("上面代码的分割规则是 0 次或多次的 a，由于正则默认是贪婪匹配，所以例一的第一个分隔符是 aaa，第二个分割符是 a，将字符串分成三个部分，包含开始处的空字符串。例二的第一个分隔符是 aaa，第二个分隔符是 0 个 a（即空字符），第三个分隔符是 a，所以将字符串分成四个部分。")]),a._v(" "),t("h5",{attrs:{id:"如果正则表达式带有括号-则括号匹配的部分也会作为数组成员返回"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如果正则表达式带有括号-则括号匹配的部分也会作为数组成员返回"}},[a._v("#")]),a._v(" 如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("'aaa*a*'.split(/(a*)/)\n// [ '', 'aaa', '*', 'a', '*' ]\n")])])]),t("h4",{attrs:{id:"es6-的扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6-的扩展"}},[a._v("#")]),a._v(" ES6 的扩展")]),a._v(" "),t("p",[a._v("ES6 出现之前，字符串对象共有 4 个方法，可以使用正则表达式："),t("code",[a._v("match()")]),a._v("、"),t("code",[a._v("replace()")]),a._v("、"),t("code",[a._v("search()")]),a._v("和"),t("code",[a._v("split()")]),a._v("。")]),a._v(" "),t("p",[a._v("ES6 将这 4 个方法，在语言内部全部调用 RegExp 的实例方法，从而做到所有与正则相关的方法，全都定义在 RegExp 对象上。")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("String.prototype.match")]),a._v(" 调用 "),t("code",[a._v("RegExp.prototype[Symbol.match]")])]),a._v(" "),t("li",[t("code",[a._v("String.prototype.replace")]),a._v(" 调用 "),t("code",[a._v("RegExp.prototype[Symbol.replace]")])]),a._v(" "),t("li",[t("code",[a._v("String.prototype.search")]),a._v(" 调用 "),t("code",[a._v("RegExp.prototype[Symbol.search]")])]),a._v(" "),t("li",[t("code",[a._v("String.prototype.split")]),a._v(" 调用 "),t("code",[a._v("RegExp.prototype[Symbol.split]")])])]),a._v(" "),t("p",[a._v("例如：")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" re "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("[0-9]+")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-flags"}},[a._v("g")])]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" str "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'2022-01-02'")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" result "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" re"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Symbol"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("match"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("str"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\nconsole"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("result"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v('// ["2022", "01", "02"]')]),a._v("\n")])])]),t("h2",{attrs:{id:"进阶概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进阶概念"}},[a._v("#")]),a._v(" 进阶概念")]),a._v(" "),t("h3",{attrs:{id:"匹配模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#匹配模式"}},[a._v("#")]),a._v(" 匹配模式")]),a._v(" "),t("h4",{attrs:{id:"贪婪模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#贪婪模式"}},[a._v("#")]),a._v(" 贪婪模式")]),a._v(" "),t("p",[a._v("正则表达式的匹配模式，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var s = 'aaa';\ns.match(/a+/) // [\"aaa\"]\n")])])]),t("p",[a._v("上面代码中，模式是 "),t("code",[a._v("/a+/")]),a._v("，表示匹配 1 个 a 或多个 a，那么到底会匹配几个 a 呢？因为默认是贪婪模式，会一直匹配到字符 a 不出现为止，所以匹配结果是 3 个 a。")]),a._v(" "),t("h4",{attrs:{id:"非贪婪模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#非贪婪模式"}},[a._v("#")]),a._v(" 非贪婪模式")]),a._v(" "),t("p",[a._v("非贪婪模式又称懒惰模式，只需要在待匹配的量词字符后面跟随一个问号即可："),t("code",[a._v("??")]),a._v("、"),t("code",[a._v("+?")]),a._v("、"),t("code",[a._v("*?")]),a._v("、"),t("code",[a._v("{1,5}?")]),a._v("，一旦条件满足，就不再往下匹配。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var s = 'aaa';\ns.match(/a+?/) // [\"a\"]\n")])])]),t("h5",{attrs:{id:"再举一个例子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#再举一个例子"}},[a._v("#")]),a._v(" 再举一个例子")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("'aabab'.match(/a.*?b/g) // ['aab', 'ab']\n")])])]),t("p",[t("code",[a._v("a.*?b")]),a._v(" 匹配最短的，以 a 开始，以 b 结束的字符串。把它应用于 aabab 的话，它会匹配 aab（第一到第三个字符）和 ab（第四到第五个字符）。")]),a._v(" "),t("p",[a._v("为什么第一个匹配是 aab（第一到第三个字符）而不是 ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先匹配到的拥有最高的优先权——The match that begins earliest wins。")]),a._v(" "),t("h4",{attrs:{id:"独占模式-js-暂不支持"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#独占模式-js-暂不支持"}},[a._v("#")]),a._v(" 独占模式（JS 暂不支持）")]),a._v(" "),t("p",[a._v("独占模式需要在待匹配的量词字符后面跟随一个加号即可："),t("code",[a._v("?+")]),a._v("、"),t("code",[a._v("++")]),a._v("、"),t("code",[a._v("*+")]),a._v("、"),t("code",[a._v("{1,5}+")]),a._v("。同贪婪模式一样，独占模式一样会匹配最长。不过在独占模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而不会回溯。")]),a._v(" "),t("h3",{attrs:{id:"匹配顺序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#匹配顺序"}},[a._v("#")]),a._v(" 匹配顺序")]),a._v(" "),t("p",[a._v("通常情况下，正则将会从左到右地测试每个条件。")]),a._v(" "),t("h4",{attrs:{id:"使用分枝条件时-要注意各个条件的顺序。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用分枝条件时-要注意各个条件的顺序。"}},[a._v("#")]),a._v(" 使用分枝条件时，要注意各个条件的顺序。")]),a._v(" "),t("p",[a._v("如果满足了某个分枝的话，就不会去再管其它的条件了。")]),a._v(" "),t("p",[a._v("例如：美国邮编的规则是 5 位数字，或者用连字号间隔的 9 位数字。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/\\d{5}-\\d{4}|\\d{5}/ // 正确方式\n/\\d{5}|\\d{5}-\\d{4}/ // 错误方式，只会匹配5位的邮编(以及9位邮编的前5位)\n")])])]),t("h3",{attrs:{id:"断言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#断言"}},[a._v("#")]),a._v(" 断言")]),a._v(" "),t("p",[a._v("断言（Assertion）也被称为零宽断言或环视（lookaround），它代表的是一个位置，这个位置应该满足一定的条件（断言），只有当断言为真时才会认为其之前或之后的正则匹配成功。")]),a._v(" "),t("p",[a._v("它自身只进行子表达式的匹配，不占有字符，匹配到的内容不保存到最终的匹配结果。")]),a._v(" "),t("h4",{attrs:{id:"先行断言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#先行断言"}},[a._v("#")]),a._v(" 先行断言")]),a._v(" "),t("p",[a._v("先行断言（lookahead）有时也被称作正向断言，语法是："),t("code",[a._v("(?=exp)")]),a._v("，用于检查某个特定模式是否出现在另一个模式的后面（右边），通俗点说，在某个位置往右（往后）看是否匹配 "),t("code",[a._v("?=")]),a._v(" 后面的子表达式。")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" m "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'abcabd'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("match")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("b(?=c)")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v('// ["b"]')]),a._v("\n")])])]),t("p",[a._v("上面代码中，匹配 b 的地方有两个，然后从这两个位置往右看是否匹配正向断言的子表达式 c，所以只有第一个 b 是真正匹配成功的。")]),a._v(" "),t("h5",{attrs:{id:"密码强度校验-举例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#密码强度校验-举例"}},[a._v("#")]),a._v(" 密码强度校验（举例）")]),a._v(" "),t("p",[a._v("至少有一个大写字母。至少有一个小写字母。至少有一个数字。至少有 8 个字符。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d).{8,}$/.test('123456aA') // true\n")])])]),t("p",[a._v("这是一个特殊的例子，用于检查字符串中是否至少有一个大写字母等。")]),a._v(" "),t("p",[t("code",[a._v("(?=.*[A-Z])")]),a._v("：用于检查字符串中是否存在至少一个大写字母。其中：")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("?=")]),a._v(" 是先行断言的开始。")]),a._v(" "),t("li",[t("code",[a._v(".*")]),a._v(" 代表任意数量的任意字符，这意味着大写字母可以出现在字符串中的任意位置。")]),a._v(" "),t("li",[t("code",[a._v("[A-Z]")]),a._v(" 匹配任意一个大写字母。")])]),a._v(" "),t("h4",{attrs:{id:"先行否定断言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#先行否定断言"}},[a._v("#")]),a._v(" 先行否定断言")]),a._v(" "),t("p",[a._v("先行否定断言（negative lookahead）有时也被称为正向否定断言，语法是："),t("code",[a._v("(?!=exp)")]),a._v("，用于确保某个模式后面不跟随另一个特定的模式")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/\\d+(?!\\.)/.exec('3.14') // [\"14\"]\n")])])]),t("p",[a._v("上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是 14。")]),a._v(" "),t("h5",{attrs:{id:"数字格式化-举例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数字格式化-举例"}},[a._v("#")]),a._v(" 数字格式化（举例）")]),a._v(" "),t("p",[a._v("1234567890 格式化为 1,234,567,890")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" test "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'1234567890'")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" reg "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token regex"}},[t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[a._v("\\B(?=(\\d{3})+(?!\\d))")]),t("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token regex-flags"}},[a._v("g")])]),a._v("\nconsole"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("test"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("replace")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("reg"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("','")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),t("p",[a._v("主要看一下正则表达式部分：")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("\\B")]),a._v(" 非词边界，即在词内部的间隔处")]),a._v(" "),t("li",[t("code",[a._v("?=")]),a._v(" 先行断言，后面必须匹配\n"),t("ul",[t("li",[t("code",[a._v("(\\d{3})+")]),a._v(" 1 个或多个连续的三个数字")]),a._v(" "),t("li",[t("code",[a._v("?!")]),a._v(" 先行否定断言，多个连续的三个数字后不能有数字")])])])]),a._v(" "),t("h4",{attrs:{id:"后行断言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后行断言"}},[a._v("#")]),a._v(" 后行断言")]),a._v(" "),t("p",[a._v("后行断言（lookbehind）有时也被称为反向断言，语法是："),t("code",[a._v("(?<=exp)")]),a._v("，用于检查某个特定模式是否出现在另一个模式的前面（左边）。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/(?<=\\$)\\d+/.exec('123$100') // 100\n")])])]),t("p",[a._v("“后行断言”的实现，需要先匹配 "),t("code",[a._v("/(?<=y)x/")]),a._v(" 的 "),t("code",[a._v("x")]),a._v("，然后再回到左边，匹配 "),t("code",[a._v("y")]),a._v(" 的部分。这种“先右后左”的执行顺序（后行），与所有其他正则操作相反，导致了一些不符合预期的行为。")]),a._v(" "),t("h5",{attrs:{id:"后行断言的组匹配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后行断言的组匹配"}},[a._v("#")]),a._v(" 后行断言的组匹配")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('/^(\\d+)(\\d+)$/.exec(\'1053\') // ["1053", "105", "3"]\n')])])]),t("p",[a._v("没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是 105 和 3。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('/(?<=(\\d+)(\\d+))$/.exec(\'1053\') // ["", "1", "053"]\n')])])]),t("p",[a._v("有“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是 1 和 053。")]),a._v(" "),t("h5",{attrs:{id:"后行断言的引用字符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后行断言的引用字符"}},[a._v("#")]),a._v(" 后行断言的引用字符")]),a._v(" "),t("p",[a._v("如果后行断言的反斜杠引用字符（"),t("code",[a._v("\\1")]),a._v("）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。"),t("strong",[a._v("因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/(?<=(o)d\\1)r/.exec('hodor')  // null\n/(?<=\\1d(o))r/.exec('hodor')  // [\"r\", \"o\"]\n")])])]),t("h4",{attrs:{id:"后行否定断言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后行否定断言"}},[a._v("#")]),a._v(" 后行否定断言")]),a._v(" "),t("p",[a._v("后行否定断言（negative lookbehind）有时也被称为反向否定断言，语法是："),t("code",[a._v("(?<!exp)")]),a._v("，用于确保某个模式前面不是另一个特定的模式。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/(?<!\\$)\\d+/.exec('123$100') // 123\n")])])]),t("h2",{attrs:{id:"正则表达式引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式引擎"}},[a._v("#")]),a._v(" 正则表达式引擎")]),a._v(" "),t("p",[a._v("正则表达式的执行需要正则引擎，正则引擎主要分为两类：")]),a._v(" "),t("ul",[t("li",[a._v("DFA（Deterministic finite automaton） 确定型有穷自动机\n"),t("ul",[t("li",[a._v("使用 DFA 引擎的程序：awk（大多数版本）、egrep（大多数版本）、flex、lex、MySQL 等")])])]),a._v(" "),t("li",[a._v("NFA（Non-deterministic finite automaton）不确定型有穷自动机\n"),t("ul",[t("li",[a._v("使用 NFA 引擎的程序：Java、Perl、PCRE library、less、more、sed（大多数版本）、Python、Ruby 等")]),a._v(" "),t("li",[a._v("一般指的是 Traditional NFA")])])])]),a._v(" "),t("p",[a._v("其实：NFA 还能继续分为 Traditional NFA 和 POSIX NFA，这就跟 PCRE 流派和 POSIX 流派有些关系了，另外还有一些程序支持 DFA 和 NFA 的结合体，例如 GNU awk")]),a._v(" "),t("h4",{attrs:{id:"确定型和不确定型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#确定型和不确定型"}},[a._v("#")]),a._v(" 确定型和不确定型")]),a._v(" "),t("p",[a._v("假设有一个字符串 abc 需要匹配，在没有编写正则表达式的前提下，"),t("strong",[a._v("直接可以确定字符匹配顺序的就是确定型，不能确定字符匹配顺序的就是不确定型")]),a._v("。")]),a._v(" "),t("h4",{attrs:{id:"有穷"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有穷"}},[a._v("#")]),a._v(" 有穷")]),a._v(" "),t("p",[a._v("有穷即表示有限的意思，这里表示有限的次数内能得到结果")]),a._v(" "),t("h4",{attrs:{id:"自动机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自动机"}},[a._v("#")]),a._v(" 自动机")]),a._v(" "),t("p",[a._v("自动机就是自动完成，在我们设置好匹配规则后由引擎会自动完成，不需要人为干预。")]),a._v(" "),t("h3",{attrs:{id:"dfa-引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dfa-引擎"}},[a._v("#")]),a._v(" DFA 引擎")]),a._v(" "),t("p",[a._v("DFA 是从匹配文本入手，从左到右，每个字符不会匹配两次，它的时间复杂度是多项式的，所以通常情况下，它的速度更快，但支持的特性很少，不支持捕获组、各种引用等等")]),a._v(" "),t("p",[a._v("正则里面的 DFA 引擎实际上就是把正则表达式转换成一个图的邻接表，然后通过跳表的形式判断一个字符串是否匹配该正则。")]),a._v(" "),t("h4",{attrs:{id:"dfa-的特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dfa-的特点"}},[a._v("#")]),a._v(" DFA 的特点")]),a._v(" "),t("ul",[t("li",[a._v("先看文本，再看正则，"),t("strong",[a._v("以文本为主导")])]),a._v(" "),t("li",[a._v("匹配过程，字符串只看一次，不管正则表达式写得多烂，匹配速度都很快")]),a._v(" "),t("li",[a._v("不支持捕获组、断言等高级功能")])]),a._v(" "),t("h3",{attrs:{id:"nfa-引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nfa-引擎"}},[a._v("#")]),a._v(" NFA 引擎")]),a._v(" "),t("p",[a._v("NFA 是从正则表达式入手，不断读入字符，尝试是否匹配当前正则，不匹配则吐出字符重新尝试，通常它的速度比较慢，最优时间复杂度为多项式的，最差情况为指数级的。但 NFA 支持更多的特性，因而绝大多数编程场景下（包括 Java，JS），就是 NFA。")]),a._v(" "),t("p",[a._v("正则里面 NFA 引擎实际上就是在语法解析的时候，构造出的一个有向图。然后通过深搜的方式，去一条路径一条路径的递归尝试。")]),a._v(" "),t("h4",{attrs:{id:"nfa-的特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nfa-的特点"}},[a._v("#")]),a._v(" NFA 的特点")]),a._v(" "),t("ul",[t("li",[a._v("先看正则，再看文本，"),t("strong",[a._v("以正则为主导")])]),a._v(" "),t("li",[a._v("匹配过程中，可能会发生回退，字符串同一部分会比较多次（通常将回退称为“回溯”）")]),a._v(" "),t("li",[a._v("功能强大，可以拿到匹配的上下文信息，支持捕获组、断言等功能")])]),a._v(" "),t("h3",{attrs:{id:"灾难性回溯真实案例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#灾难性回溯真实案例"}},[a._v("#")]),a._v(" 灾难性回溯真实案例")]),a._v(" "),t("p",[a._v("大部分语言的正则引擎都是 NFA 的，JS 也是，如果写出了有性能问题的正则表达式，容易造成灾难性回溯。")]),a._v(" "),t("p",[a._v("使用 "),t("a",{attrs:{href:"https://regex101.com/",target:"_blank",rel:"noopener noreferrer"}},[a._v("regex101"),t("OutboundLink")],1),a._v(" 统计 step")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('let regexp = /^(\\w+\\s?)*$/;\n\nalert( regexp.test("A good string") ); // true 一共 14 steps\nalert( regexp.test("Bad characters: $@#") ); // false 一共 16412 steps，如果字符串再长一点会执行更多 step\n')])])]),t("ul",[t("li",[t("a",{attrs:{href:"https://zh.javascript.info/regexp-catastrophic-backtracking",target:"_blank",rel:"noopener noreferrer"}},[a._v("必看-灾难性回溯"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://www.cnblogs.com/study-everyday/p/7426862.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("一个由正则表达式引发的血案"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MjM5NjA1NzEwMA==&mid=2651019020&idx=1&sn=49ea80e217d17703647ae40fff0c0369&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[a._v("觅迹寻踪之正则表达式"),t("OutboundLink")],1)])]),a._v(" "),t("h4",{attrs:{id:"如何避免"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何避免"}},[a._v("#")]),a._v(" 如何避免")]),a._v(" "),t("ul",[t("li",[a._v("改用 DFA 的正则引擎（速度快，功能弱，没有捕获组断言等功能）")]),a._v(" "),t("li",[a._v("提高对正则性能问题的重视，开发的时候少写模糊匹配，越精确越好，因为模糊匹配、贪婪匹配、懒惰匹配都可能带来回溯问题")]),a._v(" "),t("li",[a._v("使用独占模式可以有效避免回溯问题（JS 暂时没有此模式）")]),a._v(" "),t("li",[a._v("不要滥用括号和字符类")]),a._v(" "),t("li",[a._v("拆分表达式，有时候，多个小正则表达式的速度比一个大正则表达式的速度要快")])]),a._v(" "),t("h2",{attrs:{id:"性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#性能"}},[a._v("#")]),a._v(" 性能")]),a._v(" "),t("h3",{attrs:{id:"基本概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本概述"}},[a._v("#")]),a._v(" 基本概述")]),a._v(" "),t("h4",{attrs:{id:"正则表达式的性能高于常规的循环遍历字符串操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式的性能高于常规的循环遍历字符串操作"}},[a._v("#")]),a._v(" 正则表达式的性能高于常规的循环遍历字符串操作")]),a._v(" "),t("h4",{attrs:{id:"如果只需要匹配几个字母的大小写-可以直接写明-如果使用-i修饰符-会每个字母都匹配一遍大小写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如果只需要匹配几个字母的大小写-可以直接写明-如果使用-i修饰符-会每个字母都匹配一遍大小写"}},[a._v("#")]),a._v(" 如果只需要匹配几个字母的大小写，可以直接写明，如果使用 "),t("code",[a._v("i")]),a._v("修饰符，会每个字母都匹配一遍大小写")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/[MmSs]/.test('mS')\n")])])]),t("h4",{attrs:{id:"尽量使用正则表达式字面量形式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#尽量使用正则表达式字面量形式"}},[a._v("#")]),a._v(" 尽量使用正则表达式字面量形式")]),a._v(" "),t("p",[a._v("因为 JavaScript 引擎会在脚本加载时编译正则表达式字面量。相比之下，使用 "),t("code",[a._v("RegExp")]),a._v(" 构造函数创建的正则表达式可能会在每次使用时都重新编译")]),a._v(" "),t("h4",{attrs:{id:"使用行或者字符串的开始、结束符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用行或者字符串的开始、结束符"}},[a._v("#")]),a._v(" 使用行或者字符串的开始、结束符")]),a._v(" "),t("p",[a._v("如果是从行首或者行尾匹配，使用 "),t("code",[a._v("^")]),a._v(" 或 "),t("code",[a._v("$")]),a._v(" 能更精准匹配")]),a._v(" "),t("h2",{attrs:{id:"扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#扩展"}},[a._v("#")]),a._v(" 扩展")]),a._v(" "),t("h3",{attrs:{id:"匹配中文字符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#匹配中文字符"}},[a._v("#")]),a._v(" 匹配中文字符")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("[\\u4e00-\\u9fa5]")]),a._v(" 是错的，不要用二十年前的正则表达式了")]),a._v(" "),t("li",[t("code",[a._v("/\\p{Unified_Ideograph}/u")]),a._v(" 是正确的，不需要维护，匹配所有汉字。这里 "),t("code",[a._v("\\p")]),a._v(" 是 Unicode 属性转义正则表达式，并且需要使用 "),t("code",[a._v("u")]),a._v(" 修饰符。")]),a._v(" "),t("li",[t("code",[a._v("/\\p{Ideographic}/u")]),a._v(" 和 "),t("code",[a._v("/\\p{Script=Han}/u")]),a._v(" 匹配除了汉字以外的其他一些字符，太宽泛，在「汉字匹配正则表达式」这个需求下，是错的。")]),a._v(" "),t("li",[a._v("目前只有 Chrome 支持 Unicode 属性转义正则表达式。对其他环境，使用 @babel/plugin-proposal-unicode-property-regex 和 regexpu-core 进行优雅降级。")])]),a._v(" "),t("p",[a._v("具体细节可以看")]),a._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzAwNTAzMjcxNg%3D%3D&mid=2651425175&idx=1&sn=87dfcb5cee723f8a2997f2376f8f17e1#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[a._v("JavaScript 正则表达式匹配汉字"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://www.bookstack.cn/read/zh.javascript.info/49063ecacf52dcca.md",target:"_blank",rel:"noopener noreferrer"}},[a._v("Unicode：修饰符 “u” 和 class \\p{…}"),t("OutboundLink")],1)])]),a._v(" "),t("h2",{attrs:{id:"链接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链接"}},[a._v("#")]),a._v(" 链接")]),a._v(" "),t("h3",{attrs:{id:"技术文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#技术文章"}},[a._v("#")]),a._v(" 技术文章")]),a._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/hYYDRHgjBs0TVTQty9pSBw",target:"_blank",rel:"noopener noreferrer"}},[a._v("梳理正则表达式发展史"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://wangdoc.com/javascript/stdlib/regexp",target:"_blank",rel:"noopener noreferrer"}},[a._v("RegExp 对象"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://www.bookstack.cn/read/zh.javascript.info/bf6e57fcc0ce32fb.md",target:"_blank",rel:"noopener noreferrer"}},[a._v("现代 JavaScript 教程中文版-正则表达式"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000021787021",target:"_blank",rel:"noopener noreferrer"}},[a._v("正则表达式引擎执行原理"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"http://www.alloyteam.com/2019/07/13574/",target:"_blank",rel:"noopener noreferrer"}},[a._v("浅谈正则表达式原理"),t("OutboundLink")],1)])]),a._v(" "),t("h3",{attrs:{id:"验证和联系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#验证和联系"}},[a._v("#")]),a._v(" 验证和联系")]),a._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://regex101.com/",target:"_blank",rel:"noopener noreferrer"}},[a._v("regex101"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://jex.im/regulex/#!flags=&re=%5E(a%7Cb)*%3F%24",target:"_blank",rel:"noopener noreferrer"}},[a._v("JavaScript Regular Expression Visualizer"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://regexone.com/",target:"_blank",rel:"noopener noreferrer"}},[a._v("正则练习 RegexOne - Learn Regular Expressions"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://any86.github.io/any-rule/",target:"_blank",rel:"noopener noreferrer"}},[a._v("正则大全"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/francisrstokes/super-expressive",target:"_blank",rel:"noopener noreferrer"}},[a._v("super-expressive 用自然语言的方式构建正则表达式"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=r.exports}}]);