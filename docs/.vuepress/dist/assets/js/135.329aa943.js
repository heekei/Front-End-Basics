(window.webpackJsonp=window.webpackJsonp||[]).push([[135],{567:function(t,v,_){"use strict";_.r(v);var a=_(25),s=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"react-相关概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#react-相关概念"}},[t._v("#")]),t._v(" React 相关概念")]),t._v(" "),v("h2",{attrs:{id:"现代框架如何描述-ui"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#现代框架如何描述-ui"}},[t._v("#")]),t._v(" 现代框架如何描述 UI？")]),t._v(" "),v("p",[t._v("现代框架基本上都认为“UI 本质上与逻辑存在耦合的部分”，开发者可以：")]),t._v(" "),v("ul",[v("li",[t._v("在 UI 上绑定事件")]),t._v(" "),v("li",[t._v("在状态变化后改变 UI 的样式或结构")])]),t._v(" "),v("p",[t._v("所以有两种主流“描述 UI 的方案”：")]),t._v(" "),v("ul",[v("li",[t._v("JSX")]),t._v(" "),v("li",[t._v("模板语言")])]),t._v(" "),v("h3",{attrs:{id:"jsx"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jsx"}},[t._v("#")]),t._v(" JSX")]),t._v(" "),v("p",[t._v("JSX 是一种“类 XML 语法”的 ECMAScript 语法糖，是对 ECMAScript 的一种类 XML 的语法扩展，但它没有定义任何语意，其专门提供给预处理器使用。")]),t._v(" "),v("p",[t._v("React 使用 JSX 描述 UI 有两个原因：")]),t._v(" "),v("ul",[v("li",[t._v("前端工程师熟悉 HTML，并且使用 JS 编写逻辑，因此，如果同样使用 JS 描述 UI，即可使 UI 与逻辑配合更密切。")]),t._v(" "),v("li",[t._v("JSX 能够灵活地与其他 JS 语法组合使用，这种灵活性使 JSX 可以轻松描述“复杂的 UI”，与逻辑结合，即可轻松描述“复杂的 UI 变化”。但是高灵活性意味着 JSX 需要牺牲“潜在的编译时优化空间”。")])]),t._v(" "),v("h3",{attrs:{id:"模板语言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模板语言"}},[t._v("#")]),t._v(" 模板语言")]),t._v(" "),v("p",[t._v("模板语言是从后端发展而来的，早期 PHP（Hypertext Preprocessor 超文本处理器）更多是作为 HTML 模板语言出现的，之后许多编程语言都实现了 PHP 风格的模板语法：")]),t._v(" "),v("ul",[v("li",[t._v("基于 Java 的 JSP")]),t._v(" "),v("li",[t._v("基于 PHP 二次封装的 smarty")]),t._v(" "),v("li",[t._v("基于 ES 的 EJS")])]),t._v(" "),v("p",[t._v("虽然这类模板语法的功能强大，但是当页面结构复杂时，逻辑会不可避免地与 UI 结合起来应用。")]),t._v(" "),v("p",[t._v("为了更好地展示 UI，“重 UI 轻逻辑”的模板解析引擎 Mustache 出现。")]),t._v(" "),v("p",[t._v("虽然 Mustache 能够简练、直观地表达 UI，但是缺失逻辑的表达能力。所以一些模板语法尝试在 UI 与逻辑之间寻找平衡，或者在原有的 HTML 语法基础上进行扩展。")]),t._v(" "),v("p",[t._v("模板语法的优点是：其 UI 与逻辑都是合法的 HTML 语法，可以直接在浏览器中正常显示“未替换的原始模板页面”。")]),t._v(" "),v("h3",{attrs:{id:"jsx-与模板语法的差异"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jsx-与模板语法的差异"}},[t._v("#")]),t._v(" JSX 与模板语法的差异")]),t._v(" "),v("p",[t._v("模板语法的出发点：既然前端框架使用 HTML 描述 UI，就扩展 HTML 语法，使它能够描述逻辑。即“从 UI 出发，扩展 UI，描述逻辑”")]),t._v(" "),v("p",[t._v("JSX 的出发点：既然前端框架使用 JS 描述逻辑，那就扩展 ES 语法，使它能够描述 UI，即“从逻辑出发，扩展逻辑，描述 UI”")]),t._v(" "),v("h2",{attrs:{id:"现代框架的在-编译-时有哪些不同方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#现代框架的在-编译-时有哪些不同方案"}},[t._v("#")]),t._v(" 现代框架的在“编译”时有哪些不同方案？")]),t._v(" "),v("h3",{attrs:{id:"编译有什么作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#编译有什么作用"}},[t._v("#")]),t._v(" 编译有什么作用？")]),t._v(" "),v("ul",[v("li",[t._v("将“框架中描述的 UI”转换为宿主环境可识别的代码")]),t._v(" "),v("li",[t._v("代码转化，比如将 ts 编译为 js、实现 ployfill 等")]),t._v(" "),v("li",[t._v("执行一些编译时优化")]),t._v(" "),v("li",[t._v("代码打包、压缩、混淆")])]),t._v(" "),v("h2",{attrs:{id:"编译执行的两个时机"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#编译执行的两个时机"}},[t._v("#")]),t._v(" 编译执行的两个时机")]),t._v(" "),v("ul",[v("li",[t._v("AOT：Ahead Of Time 提前编译或预编译，代码在构建时执行编译，宿主环境获得的是编译后的代码")]),t._v(" "),v("li",[t._v("JIT：Just In Time 即时编译，代码在宿主环境执行时，在宿主环境中编译并执行。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);