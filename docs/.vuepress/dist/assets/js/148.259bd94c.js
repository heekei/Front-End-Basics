(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{584:function(e,t,v){"use strict";v.r(t);var _=v(25),r=Object(_.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"vue2-和-vue3-响应系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue2-和-vue3-响应系统"}},[e._v("#")]),e._v(" Vue2 和 Vue3 响应系统")]),e._v(" "),t("h2",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),t("p",[e._v("Vue 2 和 Vue 3 在实现响应性的目标相同即在数据变化时自动更新视图，但他们的实现方式不一样，它们使用了不同的技术栈和方法。Vue 2 使用的是 "),t("strong",[e._v("Object.defineProperty")]),e._v(" 来实现响应式数据的代理，Vue 3 使用的是 "),t("strong",[e._v("Proxy")]),e._v(" 来实现响应式数据的代理。下面先简单聊聊 "),t("strong",[e._v("Object.defineProperty")]),e._v(" 和 "),t("strong",[e._v("Proxy")])]),e._v(" "),t("h2",{attrs:{id:"object-defineproperty-和-proxy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty-和-proxy"}},[e._v("#")]),e._v(" Object.defineProperty 和 proxy")]),e._v(" "),t("p",[t("code",[e._v("Object.defineProperty")]),e._v(" 和 "),t("code",[e._v("Proxy")]),e._v(" 是 JavaScript 中控制对象的属性访问与修改的两种方式，它们的作用相似，但使用方式和功能上有很大的差异。")]),e._v(" "),t("h3",{attrs:{id:"_1-object-defineproperty"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-object-defineproperty"}},[e._v("#")]),e._v(" 1. "),t("code",[e._v("Object.defineProperty")])]),e._v(" "),t("p",[t("code",[e._v("Object.defineProperty")]),e._v(" 是一种直接通过 API 设置对象属性的方法，可以让你精确地控制对象的某个属性的行为。")]),e._v(" "),t("h4",{attrs:{id:"特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[e._v("#")]),e._v(" 特点：")]),e._v(" "),t("ul",[t("li",[e._v("可以用来定义对象的属性，包括数据属性和访问器属性。")]),e._v(" "),t("li",[e._v("可以控制属性的特性，比如可写性、可枚举性、可配置性等。")]),e._v(" "),t("li",[e._v("当你需要对某个属性进行 getter、setter 或者其他更细粒度的控制时，它非常有用。")])]),e._v(" "),t("h4",{attrs:{id:"示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[e._v("#")]),e._v(" 示例：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("let obj = {};\nObject.defineProperty(obj, 'name', {\n  value: 'Alice',\n  writable: true,   // 是否可写\n  enumerable: true, // 是否可枚举\n  configurable: true, // 是否可配置\n});\n\nconsole.log(obj.name); // 输出 \"Alice\"\n\n// 设置 getter 和 setter\nObject.defineProperty(obj, 'age', {\n  get() {\n    return this._age;\n  },\n  set(value) {\n    this._age = value;\n  },\n});\n\nobj.age = 25;\nconsole.log(obj.age); // 输出 25\n")])])]),t("h4",{attrs:{id:"解释"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解释"}},[e._v("#")]),e._v(" 解释：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("value")]),e._v("：设置属性的初始值。")]),e._v(" "),t("li",[t("code",[e._v("writable")]),e._v("：控制属性值是否可被修改。")]),e._v(" "),t("li",[t("code",[e._v("enumerable")]),e._v("：控制属性是否会出现在 "),t("code",[e._v("for...in")]),e._v(" 循环中。")]),e._v(" "),t("li",[t("code",[e._v("configurable")]),e._v("：控制属性是否可以被删除或修改属性描述符。")]),e._v(" "),t("li",[t("code",[e._v("get")]),e._v(" 和 "),t("code",[e._v("set")]),e._v(" 用来控制属性的读取和设置")])]),e._v(" "),t("h3",{attrs:{id:"_2-proxy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-proxy"}},[e._v("#")]),e._v(" 2. "),t("code",[e._v("Proxy")])]),e._v(" "),t("p",[t("code",[e._v("Proxy")]),e._v(" 是 ES6 引入的一种新特性，它可以用来创建一个代理对象，该对象会拦截对原始对象的操作。通过 "),t("code",[e._v("Proxy")]),e._v("，你可以定义对象的各种操作，如读取、设置、删除属性、函数调用等。")]),e._v(" "),t("h4",{attrs:{id:"特点-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特点-2"}},[e._v("#")]),e._v(" 特点：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("Proxy")]),e._v(" 允许你定义多种不同类型的操作拦截器。")]),e._v(" "),t("li",[e._v("可以拦截 "),t("code",[e._v("get")]),e._v("、"),t("code",[e._v("set")]),e._v("、"),t("code",[e._v("has")]),e._v("、"),t("code",[e._v("deleteProperty")]),e._v(" 等多个操作。")]),e._v(" "),t("li",[e._v("更加灵活和强大，能够拦截并自定义几乎所有操作。")])]),e._v(" "),t("h4",{attrs:{id:"示例-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#示例-2"}},[e._v("#")]),e._v(" 示例：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('let person = {\n  name: \'Alice\',\n  age: 25,\n};\n\nlet proxy = new Proxy(person, {\n  get(target, prop) {\n    if (prop in target) {\n      return target[prop];\n    } else {\n      return `Property ${prop} does not exist`;\n    }\n  },\n  set(target, prop, value) {\n    if (prop === \'age\' && value < 0) {\n      throw new Error(\'Age cannot be negative\');\n    } else {\n      target[prop] = value;\n      return true; // 需要返回 true 表示操作成功\n    }\n  },\n});\n\nconsole.log(proxy.name); // 输出 "Alice"\nconsole.log(proxy.age); // 输出 25\nconsole.log(proxy.gender); // 输出 "Property gender does not exist"\n\n// 尝试设置无效的值\ntry {\n  proxy.age = -5; // 抛出错误 "Age cannot be negative"\n} catch (e) {\n  console.log(e.message); // 输出 "Age cannot be negative"\n}\n\nproxy.age = 30; // 更新 age\nconsole.log(proxy.age); // 输出 30\n')])])]),t("h4",{attrs:{id:"解释-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解释-2"}},[e._v("#")]),e._v(" 解释：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("get")]),e._v("：拦截对属性的读取。")]),e._v(" "),t("li",[t("code",[e._v("set")]),e._v("：拦截对属性的修改。")]),e._v(" "),t("li",[t("code",[e._v("target")]),e._v("：被代理的对象。")]),e._v(" "),t("li",[t("code",[e._v("prop")]),e._v("：属性名。")]),e._v(" "),t("li",[t("code",[e._v("value")]),e._v("：属性值。")]),e._v(" "),t("li",[t("code",[e._v("return true")]),e._v("：设置操作必须返回 "),t("code",[e._v("true")]),e._v(" 表示操作成功。")])]),e._v(" "),t("h3",{attrs:{id:"_3-object-defineproperty-vs-proxy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-object-defineproperty-vs-proxy"}},[e._v("#")]),e._v(" 3."),t("code",[e._v("Object.defineProperty")]),e._v(" vs "),t("code",[e._v("Proxy")])]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("特性")]),e._v(" "),t("th",[t("code",[e._v("Object.defineProperty")])]),e._v(" "),t("th",[t("code",[e._v("Proxy")])])])]),e._v(" "),t("tbody",[t("tr",[t("td",[t("strong",[e._v("拦截操作")])]),e._v(" "),t("td",[e._v("仅限于获取或修改单一属性（getter/setter）")]),e._v(" "),t("td",[e._v("可拦截所有的操作（读取、写入、删除、函数调用等）")])]),e._v(" "),t("tr",[t("td",[t("strong",[e._v("性能")])]),e._v(" "),t("td",[e._v("更高效，适合对单一属性进行精细化控制")]),e._v(" "),t("td",[e._v("灵活但可能稍慢，特别是涉及到复杂的拦截时")])]),e._v(" "),t("tr",[t("td",[t("strong",[e._v("使用场景")])]),e._v(" "),t("td",[e._v("适合对个别属性进行控制（比如绑定、监听属性变化等）")]),e._v(" "),t("td",[e._v("适合全局性地拦截对象的行为（如数据代理、验证等）")])]),e._v(" "),t("tr",[t("td",[t("strong",[e._v("易用性")])]),e._v(" "),t("td",[e._v("使用时需要更细粒度的描述符设置")]),e._v(" "),t("td",[e._v("使用起来更简洁，能够拦截多种操作")])]),e._v(" "),t("tr",[t("td",[t("strong",[e._v("支持的特性")])]),e._v(" "),t("td",[e._v("可以定义 getter、setter、属性描述符等")]),e._v(" "),t("td",[e._v("支持 "),t("code",[e._v("get")]),e._v("、"),t("code",[e._v("set")]),e._v("、"),t("code",[e._v("has")]),e._v("、"),t("code",[e._v("deleteProperty")]),e._v("、"),t("code",[e._v("apply")]),e._v("等多种操作")])]),e._v(" "),t("tr",[t("td",[t("strong",[e._v("适用范围")])]),e._v(" "),t("td",[e._v("只能对现有对象的属性进行描述符定义")]),e._v(" "),t("td",[e._v("可以全局拦截对象的操作，包括新增、删除、修改属性等")])])])]),e._v(" "),t("p",[e._v("选择何时使用：")]),e._v(" "),t("ul",[t("li",[e._v("如果你只需要对单个属性进行精确控制（例如，设置 getter 和 setter），"),t("code",[e._v("Object.defineProperty")]),e._v(" 是更合适的选择。")]),e._v(" "),t("li",[e._v("如果你需要对整个对象进行操作拦截（例如，监控对象的所有操作，或者修改对象的行为），"),t("code",[e._v("Proxy")]),e._v(" 是更灵活和强大的选择。")])]),e._v(" "),t("p",[e._v("总结来说，"),t("code",[e._v("Object.defineProperty")]),e._v(" 用于对个别属性的行为进行细粒度控制，而 "),t("code",[e._v("Proxy")]),e._v(" 提供了更强大的功能，可以对整个对象或多种操作进行拦截。")]),e._v(" "),t("h2",{attrs:{id:"vue-2-的响应性原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-2-的响应性原理"}},[e._v("#")]),e._v(" Vue 2 的响应性原理")]),e._v(" "),t("p",[e._v("Vue 2 使用的是 "),t("strong",[e._v("Object.defineProperty")]),e._v(" 来实现响应式数据的代理。具体过程如下：")]),e._v(" "),t("h3",{attrs:{id:"_1-数据劫持-数据代理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据劫持-数据代理"}},[e._v("#")]),e._v(" 1. 数据劫持（数据代理）")]),e._v(" "),t("p",[e._v("在 Vue 2 中，Vue 会通过 "),t("code",[e._v("Object.defineProperty()")]),e._v(" 为数据对象的每个属性添加 getter 和 setter。通过这些 getter 和 setter，Vue 观察到属性的变化并触发视图更新。具体过程是：")]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[e._v("Getter")]),e._v(" ：当访问某个属性时，会触发该属性的 getter，Vue 会记录并收集这个属性的依赖。")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Setter")]),e._v(" ：当修改某个属性的值时，会触发 setter，Vue 会通知依赖这个属性的组件或视图进行更新。")])])]),e._v(" "),t("h3",{attrs:{id:"_2-依赖收集"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-依赖收集"}},[e._v("#")]),e._v(" 2. 依赖收集")]),e._v(" "),t("p",[e._v("Vue 2 在每个 getter 中都会进行 "),t("strong",[e._v("依赖收集")]),e._v(" ，将当前的 watcher（观察者）加入到该属性的依赖队列中。当属性值发生变化时，会触发 setter，然后 Vue 会通知所有依赖该属性的 watcher，进而更新视图。")]),e._v(" "),t("h3",{attrs:{id:"_3-核心实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-核心实现"}},[e._v("#")]),e._v(" 3. 核心实现")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// Vue 2 响应性实现的简化版\nlet obj = { name: 'Alice' };\n\nObject.defineProperty(obj, 'name', {\n  get() {\n    console.log('获取 name');\n    return this._name;\n  },\n  set(newValue) {\n    console.log('设置 name');\n    this._name = newValue;\n    // 触发视图更新\n    updateView();\n  }\n});\n")])])]),t("ul",[t("li",[e._v("每个属性都被 "),t("code",[e._v("Object.defineProperty")]),e._v(" 进行拦截，能够触发 getter 和 setter 操作。")]),e._v(" "),t("li",[e._v("通过这个机制，Vue 2 可以在数据变化时自动更新 DOM。")])]),e._v(" "),t("p",[e._v("局限性：")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("性能问题")]),e._v(" ：在对象中有大量属性时，逐一使用 "),t("code",[e._v("Object.defineProperty")]),e._v(" 会影响性能。")]),e._v(" "),t("li",[t("strong",[e._v("无法代理新增和删除的属性")]),e._v(" ：Vue 2 无法对已经定义的对象新增属性或删除属性进行响应式处理。")])]),e._v(" "),t("h2",{attrs:{id:"vue-3-的响应性原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-的响应性原理"}},[e._v("#")]),e._v(" Vue 3 的响应性原理")]),e._v(" "),t("p",[e._v("Vue 3 引入了全新的响应性机制，基于 "),t("strong",[e._v("Proxy")]),e._v(" ，大大优化了 Vue 2 的响应式实现。Vue 3 使用 "),t("code",[e._v("Proxy")]),e._v(" 对对象进行代理，能够更加灵活地拦截对对象的各种操作，如读取、修改、删除属性等。")]),e._v(" "),t("h3",{attrs:{id:"_1-使用-proxy-进行代理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-使用-proxy-进行代理"}},[e._v("#")]),e._v(" 1. 使用 Proxy 进行代理")]),e._v(" "),t("p",[t("code",[e._v("Proxy")]),e._v(" 可以通过设置 handler（拦截器）来拦截对象的操作，不需要逐个属性地定义 getter 和 setter。Vue 3 利用了 "),t("code",[e._v("Proxy")]),e._v(" 的能力，拦截对象上的所有操作，并动态地处理这些操作。")]),e._v(" "),t("h3",{attrs:{id:"_2-依赖收集与更新"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-依赖收集与更新"}},[e._v("#")]),e._v(" 2. 依赖收集与更新")]),e._v(" "),t("p",[e._v("Vue 3 通过 "),t("strong",[e._v("依赖追踪")]),e._v(" 来进行视图更新。当你访问对象的属性时，Vue 3 会使用 "),t("code",[e._v("Proxy")]),e._v(" 拦截器中的 "),t("code",[e._v("get")]),e._v(" 操作收集依赖。当属性的值发生变化时，Vue 3 会通过 "),t("code",[e._v("set")]),e._v(" 操作触发视图更新。")]),e._v(" "),t("h3",{attrs:{id:"_3-核心实现-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-核心实现-2"}},[e._v("#")]),e._v(" 3. 核心实现")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// Vue 3 响应性实现的简化版\nconst handler = {\n  get(target, prop) {\n    console.log(`访问属性: ${prop}`);\n    // 依赖收集\n    track(target, prop);\n    return target[prop];\n  },\n  set(target, prop, value) {\n    console.log(`修改属性: ${prop} 为 ${value}`);\n    target[prop] = value;\n    // 触发视图更新\n    trigger(target, prop);\n    return true;\n  }\n};\n\nconst obj = new Proxy({}, handler);\n\nobj.name = 'Alice';\nconsole.log(obj.name);\n")])])]),t("ul",[t("li",[t("p",[t("code",[e._v("get")]),e._v("：访问属性时会触发 "),t("code",[e._v("get")]),e._v(" 方法，用于依赖收集。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("set")]),e._v("：修改属性时会触发 "),t("code",[e._v("set")]),e._v(" 方法，用于通知视图更新。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("track")]),e._v(" 和 "),t("code",[e._v("trigger")]),e._v(" 是 Vue 3 内部的依赖收集和视图更新机制。")])])]),e._v(" "),t("h3",{attrs:{id:"_4-vue-3-响应性系统的优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-vue-3-响应性系统的优势"}},[e._v("#")]),e._v(" 4. Vue 3 响应性系统的优势")]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[e._v("性能提升")]),e._v(" ：Vue 3 通过 "),t("code",[e._v("Proxy")]),e._v(" 可以一次性代理整个对象的所有操作，而不需要为每个属性分别设置 getter 和 setter，性能更好。")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("支持新增和删除属性")]),e._v(" ：通过 "),t("code",[e._v("Proxy")]),e._v("，Vue 3 可以自动处理对象的新增和删除操作，确保新的属性能够被响应式地处理。")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("更加简洁和灵活")]),e._v(" ：由于 "),t("code",[e._v("Proxy")]),e._v(" 的设计，Vue 3 不再需要使用 "),t("code",[e._v("Object.defineProperty")]),e._v(" 的繁琐方法，可以更高效地处理对象的各种操作。")])])]),e._v(" "),t("h3",{attrs:{id:"_5-代理处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-代理处理"}},[e._v("#")]),e._v(" 5. 代理处理")]),e._v(" "),t("p",[e._v("Vue 3 通过 "),t("code",[e._v("Proxy")]),e._v(" 拦截对象的多个操作，可以代理对象的属性读取、设置、删除、函数调用等多种操作。")]),e._v(" "),t("h2",{attrs:{id:"总结-vue-2-与-vue-3-的响应性比较"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结-vue-2-与-vue-3-的响应性比较"}},[e._v("#")]),e._v(" 总结：Vue 2 与 Vue 3 的响应性比较")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("特性")]),e._v(" "),t("th",[e._v("Vue 2 ("),t("code",[e._v("Object.defineProperty")]),e._v(")")]),e._v(" "),t("th",[e._v("Vue 3 ("),t("code",[e._v("Proxy")]),e._v(")")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[t("strong",[e._v("实现方式")])]),e._v(" "),t("td",[e._v("使用 "),t("code",[e._v("Object.defineProperty")]),e._v(" 为每个属性添加 getter 和 setter")]),e._v(" "),t("td",[e._v("使用 "),t("code",[e._v("Proxy")]),e._v(" 代理整个对象，拦截所有操作")])]),e._v(" "),t("tr",[t("td",[t("strong",[e._v("性能")])]),e._v(" "),t("td",[e._v("对每个属性逐个拦截，性能较差，尤其在有大量属性时")]),e._v(" "),t("td",[e._v("通过代理拦截整个对象，性能更高")])]),e._v(" "),t("tr",[t("td",[t("strong",[e._v("新增/删除属性")])]),e._v(" "),t("td",[e._v("需要手动处理，无法响应新增或删除的属性")]),e._v(" "),t("td",[e._v("自动处理新增和删除的属性")])]),e._v(" "),t("tr",[t("td",[t("strong",[e._v("依赖收集")])]),e._v(" "),t("td",[e._v("依赖收集基于 getter")]),e._v(" "),t("td",[e._v("依赖收集通过 "),t("code",[e._v("Proxy")]),e._v("的 "),t("code",[e._v("get")]),e._v("方法实现")])]),e._v(" "),t("tr",[t("td",[t("strong",[e._v("支持的操作")])]),e._v(" "),t("td",[e._v("仅支持 "),t("code",[e._v("get")]),e._v("和 "),t("code",[e._v("set")]),e._v("操作")]),e._v(" "),t("td",[e._v("支持 "),t("code",[e._v("get")]),e._v("、"),t("code",[e._v("set")]),e._v("、"),t("code",[e._v("delete")]),e._v("、"),t("code",[e._v("has")]),e._v("、"),t("code",[e._v("apply")]),e._v("等操作")])]),e._v(" "),t("tr",[t("td",[t("strong",[e._v("使用场景")])]),e._v(" "),t("td",[e._v("适用于简单的对象或数组")]),e._v(" "),t("td",[e._v("适用于更复杂的数据结构，尤其是动态数据")])])])]),e._v(" "),t("p",[e._v("选择时的考虑")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Vue 2")]),e._v(" ：适合传统的单页面应用，尤其是那些数据结构相对简单或不需要动态增删属性的应用。")]),e._v(" "),t("li",[t("strong",[e._v("Vue 3")]),e._v(" ：使用 Proxy 后，适合需要更高性能和更灵活的数据绑定、动态操作对象的应用。")])]),e._v(" "),t("p",[e._v("总的来说，Vue 3 的响应性系统在性能和灵活性上都优于 Vue 2，得益于 "),t("code",[e._v("Proxy")]),e._v(" 的强大能力，可以更高效地处理对象的各种操作。")])])}),[],!1,null,null,null);t.default=r.exports}}]);