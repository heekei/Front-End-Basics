(window.webpackJsonp=window.webpackJsonp||[]).push([[140],{575:function(t,e,a){"use strict";a.r(e);var s=a(25),n=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react-的状态更新"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-的状态更新"}},[t._v("#")]),t._v(" React 的状态更新")]),t._v(" "),e("h2",{attrs:{id:"触发状态更新的方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#触发状态更新的方法"}},[t._v("#")]),t._v(" 触发状态更新的方法")]),t._v(" "),e("p",[t._v("React 中有以下触发状态更新的方法：")]),t._v(" "),e("ul",[e("li",[t._v("ReactDOM.render，对应的 FiberNode 的 tag 是"),e("code",[t._v("HostRoot")])]),t._v(" "),e("li",[t._v("this.setState，对应的 FiberNode 的 tag 是"),e("code",[t._v("ClassComponent")])]),t._v(" "),e("li",[t._v("this.forceUpdate，对应的 FiberNode 的 tag 是"),e("code",[t._v("ClassComponent")])]),t._v(" "),e("li",[t._v("useState dispacher，对应的 FiberNode 的 tag 是"),e("code",[t._v("FunctionComponent")])]),t._v(" "),e("li",[t._v("useReducer dispacher，对应的 FiberNode 的 tag 是"),e("code",[t._v("FunctionComponent")])])]),t._v(" "),e("p",[t._v("虽然这些方法的执行场景不同，但是都可以接入同样的更新流程，原因在于，它们使用同一种数据结构代表“更新”，这种数据结构就是 "),e("code",[t._v("Update")]),t._v("。")]),t._v(" "),e("h2",{attrs:{id:"update-的数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#update-的数据结构"}},[t._v("#")]),t._v(" update 的数据结构")]),t._v(" "),e("p",[t._v("三种不同的 tag： HostRoot、ClassComponent、FunctionComponent ，存在两种不同数据结构的 Update。")]),t._v(" "),e("h3",{attrs:{id:"hostroot-与-classcomponent-共用一种-update-结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hostroot-与-classcomponent-共用一种-update-结构"}},[t._v("#")]),t._v(" HostRoot 与 ClassComponent 共用一种 Update 结构")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("update = {\n  eventTime,\n  lane,\n\n  // 区分触发更新的场景\n  // UpdateState 代表“默认情况，通过 ReactDOM.render 或 this.setState 触发更新”\n  // ReplaceState 代表“在 ClassComponent 生命周期函数中直接改变 this.state”\n  // ForceUpdate 代表“通过 this.forceUpdate 触发更新”\n  // CaptureUpdate 代表“发生错误的情况下在 ClassComponent 或 HostRoot 中触发的更新”（比如通过 getDerivedStateFromError 方法）\n  tag: UpdateState | ReplaceState | ForceUpdate | CaptureUpdate,\n\n  // 承载变更的内容\n  // 例如：ReactDOM.createRoot(rootEle).render(<App />) 时，payload 为{element}，element 为 HostRoot 对应的 JSX，即<App />对应的 JSX\n  // 例如：this.setState({num: 1}) 时，payload 为 {num: 1}\n  // 例如：this.setState({num: (num) => num + 1}) 时，payload 为 {num: (num) => num + 1}\n  payload: null,\n\n  // UI 渲染后触发的回调函数\n  callback: null,\n\n  next: null,\n};\n")])])]),e("h3",{attrs:{id:"functioncomponent-单独使用一种-update-结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#functioncomponent-单独使用一种-update-结构"}},[t._v("#")]),t._v(" FunctionComponent 单独使用一种 Update 结构")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("update = {\n  lane,\n  // 例如：updateNum(1) 时，action:1\n  // 例如：updateNum((num) => num + 1) 时，action:(num) => num + 1\n  action,\n  // 优化策略相关字段\n  hasEagerState: false,\n  eagerState: null,\n  next: null,\n}\n")])])]),e("h3",{attrs:{id:"产生-update"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#产生-update"}},[t._v("#")]),t._v(" 产生 update")]),t._v(" "),e("p",[t._v("开发者可以在多种场景中触发更新：")]),t._v(" "),e("ul",[e("li",[t._v("回调函数中，如 onClick 回调；")]),t._v(" "),e("li",[t._v("生命周期函数中，如 UNSAFE_componentWillReceiveProps 方法内；")]),t._v(" "),e("li",[t._v("render 函数中。")])]),t._v(" "),e("h4",{attrs:{id:"按照场景划分-共有三类-update"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#按照场景划分-共有三类-update"}},[t._v("#")]),t._v(" 按照场景划分，共有三类 update")]),t._v(" "),e("ul",[e("li",[t._v("非 React 工作流程内产生的 update，比如交互触发的更新")]),t._v(" "),e("li",[t._v("RenderPhaseUpdate，render 阶段产生的 update，如 UNSAFE_componentWillReceiveProps 方法内触发的更新")]),t._v(" "),e("li",[t._v("InterleavedUpdate，除 render 阶段外，在 React 工作流程其他阶段产生的 update。")])]),t._v(" "),e("h4",{attrs:{id:"优先级低和优先级不足的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优先级低和优先级不足的区别"}},[t._v("#")]),t._v(" 优先级低和优先级不足的区别")]),t._v(" "),e("p",[t._v("在基于 lane 模型的 React 中，对于 updateLane（update 的优先级）与 renderLanes（workInProgressRootRenderLanes）：")]),t._v(" "),e("ul",[e("li",[t._v("优先级不足是指 updatelane 不包含在 renderLanes 的集合中")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  判断 updateLane 是否包含在 renderLanes 中")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("isSubsetOfLanes")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("renderLanes"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" updateLane"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("isSubsetOfLanes")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("set"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" subset")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("set "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" subset"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" subset\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("ul",[e("li",[t._v("优先级第是两个 lane 之间数字大小的直观比较")])]),t._v(" "),e("h2",{attrs:{id:"updatequeue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#updatequeue"}},[t._v("#")]),t._v(" updateQueue")]),t._v(" "),e("p",[t._v("update 是计算 state 的的最小单位，updateQueue 是保存“参与 state 计算的相关数据”的数据结构。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("updateQueue = {\n  // 代表参与计算的初始 state，每一次 update 基于该 state 计算 state\n  baseState: null,\n  // 本次更新前该 fiberNode 中已保存的 update，以链表形式存在，链表头为firstBaseUpdate，链表尾为 lastBaseUpdate\n  firstBaseUpdate: null,\n  lastBaseUpdate: null,\n  shared: {\n    // 触发更新后，产生的 update 会保存在 shared.pending 中形成单向环状链表。计算 state 时，该环状链表会被拆分并拼接在 lastBaseUpdate 后面\n    pending: null,\n    interleaved: null,\n    lanes: NoLanes,\n  },\n  effects: null,\n}\n")])])]),e("h3",{attrs:{id:"state-计算流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#state-计算流程"}},[t._v("#")]),t._v(" state 计算流程")]),t._v(" "),e("ol",[e("li",[t._v("将 baseUpdate 与 shared.pending 拼接成新链表")]),t._v(" "),e("li",[t._v("遍历拼接后的新链表，根据 workInProgressRootRenderLanes 选定的优先级，基于“符合优先级条件的 update” 计算 state")]),t._v(" "),e("li",[t._v("如果 update 没有被跳过\n"),e("ul",[e("li",[t._v("以 updateReducer 函数为例，其中 newBaseQueueLast 为 null ，代表计算过程中没有 update 被跳过")]),t._v(" "),e("li",[t._v("则“上一次 render 阶段计算出的 memoizedState”等于“下一次 render 阶段计算更新基于的 baseState”，即 memoizedState 与 baseState 一致。")])])]),t._v(" "),e("li",[t._v("如果 update 被跳过\n"),e("ul",[e("li",[t._v("以 updateReducer 函数为例，其中 newBaseQueueLast 不为 null，未参与计算的 update 会保存在 workInProgressHook 的 baseQueue 中（注意，baseQueue 是从跳过的那个 update 开始，后面链表中所有的 update），并将 beginWork 中“消费的 lane”重置，然后把每一个 update 的 lane 赋值为 NoLane。无论下次 renderLane 优先级如何， 该 update 都会在下次更新中参与计算。")]),t._v(" "),e("li",[t._v("计算的 state 为中间 state，此时 memoizedState 与 baseState 不一致")])])]),t._v(" "),e("li",[t._v("不管有没有中断此次 render 阶段，所有的 update 都会保存在 currentHook 的 baseQueue 中，防止在中断后恢复时丢失。")])]),t._v(" "),e("h3",{attrs:{id:"react-中的计算状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-中的计算状态"}},[t._v("#")]),t._v(" React 中的计算状态")]),t._v(" "),e("p",[t._v("update 拥有优先级代表不是所有 update 都能参与计算（由于优先级不足）。")]),t._v(" "),e("p",[t._v("update 之间的依赖代表互相依赖的 update 必须同时参与计算。")]),t._v(" "),e("p",[t._v("为了同时满足这两个相悖的条件，React 存在“计算不完全的中间状态”与“计算完全的最终状态”。")]),t._v(" "),e("h2",{attrs:{id:"reactdom-createroot-rootele-render-app-流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reactdom-createroot-rootele-render-app-流程"}},[t._v("#")]),t._v(" "),e("code",[t._v("ReactDOM.createRoot(rootEle).render(<App />)")]),t._v(" 流程")]),t._v(" "),e("ul",[e("li",[t._v("ReactDOM.createRoot\n"),e("ul",[e("li",[t._v("首先会调用 createContainer 创建 FiberRootNode")]),t._v(" "),e("li",[t._v("然后会调用 listenToAllSupportedEvents 初始化事件委托")]),t._v(" "),e("li",[t._v("最后返回 "),e("code",[t._v("new ReactDOMRoot(root)")]),t._v(" 实例")])])]),t._v(" "),e("li",[t._v("ReactDOMRoot 实例调用 render 方法，然后会调用 UpdateContainer ，UpdateContainer 中会调用以下方法：\n"),e("ul",[e("li",[t._v("调用 requestEventTime 获取当前时间")]),t._v(" "),e("li",[t._v("调用 requestUpdateLane 获取此次更新优先级")]),t._v(" "),e("li",[t._v("调用 createUpdate 创建 update")]),t._v(" "),e("li",[t._v("调用 enqueueUpdate 将 update 加入到 HostRootFiber 的 updateQueue")]),t._v(" "),e("li",[t._v("最后调用 scheduleUpdateOnFiber 开始调度")])])])]),t._v(" "),e("h3",{attrs:{id:"update-数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#update-数据结构"}},[t._v("#")]),t._v(" update 数据结构")]),t._v(" "),e("p",[e("code",[t._v("ReactDOMRoot.render(<App />)")]),t._v(" 执行后会开启首屏渲染流程，此时的 update 数据结构如下：")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" update "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("payload")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("element")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("App "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("tag")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" UpdateState"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("next")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 省略其他字段")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("接下来进入 schedule 阶段，调度完成后进入 render 阶段，在 HostRoot 的 beginWork 中计算 state，其中 updateQueue 的结构如下：")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" updateQueue "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("baseState")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("element")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("shared")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 上述 update")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("pending")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" update"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 省略其他字段")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 省略其他字段")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("ClassComponent 通过 this.setState 触发的更新也遵循上述流程。")]),t._v(" "),e("h3",{attrs:{id:"usestate-流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#usestate-流程"}},[t._v("#")]),t._v(" useState 流程")]),t._v(" "),e("p",[t._v("例如：")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("num"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" updateNum"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("useState")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("当 updateNum 方法执行后，会调用源码内的 dispatchSetState 方法，dispatchSetState 方法会调用以下方法：")]),t._v(" "),e("ul",[e("li",[t._v("调用 requestUpdateLane 获取此次更新优先级")]),t._v(" "),e("li",[t._v("创建 update")]),t._v(" "),e("li",[t._v("判断如果是 render 阶段触发的更新，调用 enqueueRenderPhaseUpdate，后面的流程不再执行")]),t._v(" "),e("li",[t._v("调用 enqueueUpdate(fiber, queue, update, lane) 向链表中插入 update")]),t._v(" "),e("li",[t._v("性能优化策略 eagerState")]),t._v(" "),e("li",[t._v("调用 requestEventTime 获取当前时间")]),t._v(" "),e("li",[t._v("调用 scheduleUpdateOnFiber 开始调度")])]),t._v(" "),e("h2",{attrs:{id:"状态更新的性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#状态更新的性能优化"}},[t._v("#")]),t._v(" 状态更新的性能优化")]),t._v(" "),e("h3",{attrs:{id:"性能优化的两个方向"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能优化的两个方向"}},[t._v("#")]),t._v(" 性能优化的两个方向")]),t._v(" "),e("ul",[e("li",[t._v("编写“符合性能优化策略的组件”，命中策略\n"),e("ul",[e("li",[t._v("eagerState 策略")]),t._v(" "),e("li",[t._v("bailout 策略")])])]),t._v(" "),e("li",[t._v("调用性能优化 API，命中策略。\n"),e("ul",[e("li",[t._v("shouldComponentUpdate")]),t._v(" "),e("li",[t._v("PureComponent")]),t._v(" "),e("li",[t._v("React.memo")]),t._v(" "),e("li",[t._v("UseMemo、useCallback")])])])]),t._v(" "),e("p",[t._v("上面这些性能优化的 API 的出现是由于“React 无法像 Vue 一样在编译时做出优化，因此这部分工作放在运行时交由开发者完成”。事实上，React 内部有完整的运行时性能优化策略，开发者调用性能优化 API 的本质就是命中上述 eagerState 和 bailout 策略。")]),t._v(" "),e("h3",{attrs:{id:"eagerstate-策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#eagerstate-策略"}},[t._v("#")]),t._v(" eagerState 策略")]),t._v(" "),e("p",[t._v("eagerState 策略的逻辑很简单：如果某个状态更新前后没有变化，则可以跳过后续更新流程。")]),t._v(" "),e("p",[t._v("命中该策略的更新不会进入 schedule 阶段，也不会进入 render 阶段。")]),t._v(" "),e("p",[t._v("例如，useState 触发的更新，会发生在 dispatchSetState 方法中：")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 判断 current、workInProgress 的 lanes 是否为 NoLanes，即判断当前 fiberNode 是否存在更新")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fiber"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lanes "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" NoLanes "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("alternate "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" alternate"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lanes "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" NoLanes"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果不存在，则尝试使用上次计算时使用的 reducer 计算 eagerState")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" lastRenderedReducer "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" queue"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lastRenderedReducer\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("lastRenderedReducer "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" prevDispatcher\n\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      prevDispatcher "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ReactCurrentDispatcher$1"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("current\n      ReactCurrentDispatcher$1"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("current "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" InvalidNestedHooksDispatcherOnUpdateInDEV\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" currentState "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" queue"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lastRenderedState\n      "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" eagerState "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("lastRenderedReducer")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("currentState"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" action"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n      update"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("hasEagerState "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n      update"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("eagerState "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" eagerState\n      "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("objectIs")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("eagerState"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" currentState"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// state 不变时，直接返回，不会调用 scheduleUpdateOnFiber 进入 schedule 阶段")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 即使不为 true，由于这是“当前 fiberNode 中第一个待执行更新”，在它之前不会有其他 update 影响它的计算结果，因此可以将 eagerState 保存下来。在 beginWork 中计算 state 时，对于该 update，会直接使用 eagerState，不需要在基于 update.action 计算。")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("error"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("finally")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        ReactCurrentDispatcher$1"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("current "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" prevDispatcher\n      "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" eventTime "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("requestEventTime")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" root "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("scheduleUpdateOnFiber")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fiber"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" lane"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" eventTime"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("h3",{attrs:{id:"bailout-策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bailout-策略"}},[t._v("#")]),t._v(" bailout 策略")]),t._v(" "),e("p",[t._v("进入 beginWork 后，有两次与“是否命中 bailout 策略”相关的判断。")]),t._v(" "),e("h4",{attrs:{id:"第一次发生在刚进入-beginwork-时-需要同时满足以下条件后命中-bailout-策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一次发生在刚进入-beginwork-时-需要同时满足以下条件后命中-bailout-策略"}},[t._v("#")]),t._v(" 第一次发生在刚进入 beginWork 时，需要同时满足以下条件后命中 bailout 策略")]),t._v(" "),e("ul",[e("li",[t._v("oldProps === newProps 只有当服 fiberNode 命中 bailout 策略，复用子 fiberNode，在子 fiberNode 的 beginWork 中，oldProps 才会与 newProps 全等。")]),t._v(" "),e("li",[t._v("legacy Context（旧的 Context API）没有变化")]),t._v(" "),e("li",[t._v("fiberNode.type 没有变化（函数组件中，fiberNode.type 是函数组件的执行结果）")]),t._v(" "),e("li",[t._v("当前 fiberNode 没有更新发生。")])]),t._v(" "),e("p",[t._v("没有更新发生意味着没有 state 变化。")])])}),[],!1,null,null,null);e.default=n.exports}}]);