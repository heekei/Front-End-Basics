<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>正则表达式 | Front-End-Basics</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="陈方旭的个人文档">
    
    <link rel="preload" href="/assets/css/0.styles.8f3dca9f.css" as="style"><link rel="preload" href="/assets/js/app.f0c3bf6e.js" as="script"><link rel="preload" href="/assets/js/2.267df354.js" as="script"><link rel="preload" href="/assets/js/1.66cc43cf.js" as="script"><link rel="preload" href="/assets/js/214.42974ae8.js" as="script"><link rel="prefetch" href="/assets/js/10.8ed5e327.js"><link rel="prefetch" href="/assets/js/100.ae5b3443.js"><link rel="prefetch" href="/assets/js/101.cc73b0f5.js"><link rel="prefetch" href="/assets/js/102.3f3114fb.js"><link rel="prefetch" href="/assets/js/103.8ff5fdac.js"><link rel="prefetch" href="/assets/js/104.b5debdc3.js"><link rel="prefetch" href="/assets/js/105.8da11418.js"><link rel="prefetch" href="/assets/js/106.4dbe9edc.js"><link rel="prefetch" href="/assets/js/107.181bae05.js"><link rel="prefetch" href="/assets/js/108.89a63e22.js"><link rel="prefetch" href="/assets/js/109.ce54155a.js"><link rel="prefetch" href="/assets/js/11.066e1c25.js"><link rel="prefetch" href="/assets/js/110.f2e608ea.js"><link rel="prefetch" href="/assets/js/111.42921b66.js"><link rel="prefetch" href="/assets/js/112.8da31ceb.js"><link rel="prefetch" href="/assets/js/113.5ac3f0d4.js"><link rel="prefetch" href="/assets/js/114.e056e614.js"><link rel="prefetch" href="/assets/js/115.cebf7fde.js"><link rel="prefetch" href="/assets/js/116.2b434a84.js"><link rel="prefetch" href="/assets/js/117.100c132f.js"><link rel="prefetch" href="/assets/js/118.a4afed9a.js"><link rel="prefetch" href="/assets/js/119.f0f1a25d.js"><link rel="prefetch" href="/assets/js/12.9fe465cb.js"><link rel="prefetch" href="/assets/js/120.376850c5.js"><link rel="prefetch" href="/assets/js/121.5dc1a6a2.js"><link rel="prefetch" href="/assets/js/122.363693fb.js"><link rel="prefetch" href="/assets/js/123.7258fb95.js"><link rel="prefetch" href="/assets/js/124.a4bd3167.js"><link rel="prefetch" href="/assets/js/125.8aa8db7c.js"><link rel="prefetch" href="/assets/js/126.2caa71e3.js"><link rel="prefetch" href="/assets/js/127.220486dd.js"><link rel="prefetch" href="/assets/js/128.b01fb70e.js"><link rel="prefetch" href="/assets/js/129.bd8c1b32.js"><link rel="prefetch" href="/assets/js/13.ceec992d.js"><link rel="prefetch" href="/assets/js/130.9b3fd30c.js"><link rel="prefetch" href="/assets/js/131.c1e91c2d.js"><link rel="prefetch" href="/assets/js/132.6d39b36b.js"><link rel="prefetch" href="/assets/js/133.cc4ee14d.js"><link rel="prefetch" href="/assets/js/134.3b031de3.js"><link rel="prefetch" href="/assets/js/135.329aa943.js"><link rel="prefetch" href="/assets/js/136.e97d2b91.js"><link rel="prefetch" href="/assets/js/137.70ad5edc.js"><link rel="prefetch" href="/assets/js/138.b2388813.js"><link rel="prefetch" href="/assets/js/139.260e94e8.js"><link rel="prefetch" href="/assets/js/14.6b9e2f92.js"><link rel="prefetch" href="/assets/js/140.d0752482.js"><link rel="prefetch" href="/assets/js/141.c3809389.js"><link rel="prefetch" href="/assets/js/142.909571e7.js"><link rel="prefetch" href="/assets/js/143.9c55503a.js"><link rel="prefetch" href="/assets/js/144.037eb178.js"><link rel="prefetch" href="/assets/js/145.b15eb629.js"><link rel="prefetch" href="/assets/js/146.92f941e0.js"><link rel="prefetch" href="/assets/js/147.ee679e8f.js"><link rel="prefetch" href="/assets/js/148.259bd94c.js"><link rel="prefetch" href="/assets/js/149.0560570b.js"><link rel="prefetch" href="/assets/js/15.d25af981.js"><link rel="prefetch" href="/assets/js/150.e0970997.js"><link rel="prefetch" href="/assets/js/151.8c91c562.js"><link rel="prefetch" href="/assets/js/152.b2680c3d.js"><link rel="prefetch" href="/assets/js/153.43d5659d.js"><link rel="prefetch" href="/assets/js/154.41332198.js"><link rel="prefetch" href="/assets/js/155.36a0da41.js"><link rel="prefetch" href="/assets/js/156.8d9c6ad6.js"><link rel="prefetch" href="/assets/js/157.016cc281.js"><link rel="prefetch" href="/assets/js/158.c846bda8.js"><link rel="prefetch" href="/assets/js/159.60ef4fd7.js"><link rel="prefetch" href="/assets/js/16.fe68c618.js"><link rel="prefetch" href="/assets/js/160.e000f0e7.js"><link rel="prefetch" href="/assets/js/161.f67efc97.js"><link rel="prefetch" href="/assets/js/162.4eadc328.js"><link rel="prefetch" href="/assets/js/163.39e9bbe6.js"><link rel="prefetch" href="/assets/js/164.8e990d4c.js"><link rel="prefetch" href="/assets/js/165.9cc5569d.js"><link rel="prefetch" href="/assets/js/166.dcfd67ce.js"><link rel="prefetch" href="/assets/js/167.0a12942f.js"><link rel="prefetch" href="/assets/js/168.db0cf4d8.js"><link rel="prefetch" href="/assets/js/169.0177438a.js"><link rel="prefetch" href="/assets/js/17.de0b324b.js"><link rel="prefetch" href="/assets/js/170.799f7bf1.js"><link rel="prefetch" href="/assets/js/171.72b504b4.js"><link rel="prefetch" href="/assets/js/172.3fedbd3b.js"><link rel="prefetch" href="/assets/js/173.9d2d86ef.js"><link rel="prefetch" href="/assets/js/174.1a15c5a7.js"><link rel="prefetch" href="/assets/js/175.62da2bad.js"><link rel="prefetch" href="/assets/js/176.fa85299a.js"><link rel="prefetch" href="/assets/js/177.a4f8a83d.js"><link rel="prefetch" href="/assets/js/178.3da2977b.js"><link rel="prefetch" href="/assets/js/179.5a0698c9.js"><link rel="prefetch" href="/assets/js/18.75c085a9.js"><link rel="prefetch" href="/assets/js/180.b3c22f44.js"><link rel="prefetch" href="/assets/js/181.258acfab.js"><link rel="prefetch" href="/assets/js/182.3b612a1c.js"><link rel="prefetch" href="/assets/js/183.04d35baf.js"><link rel="prefetch" href="/assets/js/184.2f6ebfb6.js"><link rel="prefetch" href="/assets/js/185.3d2ba522.js"><link rel="prefetch" href="/assets/js/186.85211aa8.js"><link rel="prefetch" href="/assets/js/187.3a727290.js"><link rel="prefetch" href="/assets/js/188.39112337.js"><link rel="prefetch" href="/assets/js/189.160e194c.js"><link rel="prefetch" href="/assets/js/19.7d112bce.js"><link rel="prefetch" href="/assets/js/190.c053d7a2.js"><link rel="prefetch" href="/assets/js/191.22cefdac.js"><link rel="prefetch" href="/assets/js/192.964f5e88.js"><link rel="prefetch" href="/assets/js/193.700abf9f.js"><link rel="prefetch" href="/assets/js/194.e267a0f1.js"><link rel="prefetch" href="/assets/js/195.e49141be.js"><link rel="prefetch" href="/assets/js/196.abd378ac.js"><link rel="prefetch" href="/assets/js/197.49b8f519.js"><link rel="prefetch" href="/assets/js/198.f60281e1.js"><link rel="prefetch" href="/assets/js/199.2444da81.js"><link rel="prefetch" href="/assets/js/20.81f5b440.js"><link rel="prefetch" href="/assets/js/200.54f5e6d4.js"><link rel="prefetch" href="/assets/js/201.132bab0f.js"><link rel="prefetch" href="/assets/js/202.cd5ef700.js"><link rel="prefetch" href="/assets/js/203.6524ae1d.js"><link rel="prefetch" href="/assets/js/204.79049883.js"><link rel="prefetch" href="/assets/js/205.b453ac0d.js"><link rel="prefetch" href="/assets/js/206.8e68e3cb.js"><link rel="prefetch" href="/assets/js/207.0dbf0bb5.js"><link rel="prefetch" href="/assets/js/208.a6f0aa62.js"><link rel="prefetch" href="/assets/js/209.5eb00898.js"><link rel="prefetch" href="/assets/js/21.b8f03079.js"><link rel="prefetch" href="/assets/js/210.5394d572.js"><link rel="prefetch" href="/assets/js/211.4d73566d.js"><link rel="prefetch" href="/assets/js/212.01ea7dd7.js"><link rel="prefetch" href="/assets/js/213.80261d17.js"><link rel="prefetch" href="/assets/js/215.6a9aefd7.js"><link rel="prefetch" href="/assets/js/216.71698897.js"><link rel="prefetch" href="/assets/js/217.cbdb7908.js"><link rel="prefetch" href="/assets/js/218.e1ca46a4.js"><link rel="prefetch" href="/assets/js/219.4bff8927.js"><link rel="prefetch" href="/assets/js/22.ce37cd53.js"><link rel="prefetch" href="/assets/js/220.d29e2c08.js"><link rel="prefetch" href="/assets/js/221.6a2c607c.js"><link rel="prefetch" href="/assets/js/222.7209db02.js"><link rel="prefetch" href="/assets/js/223.18f8b9df.js"><link rel="prefetch" href="/assets/js/224.52b820e0.js"><link rel="prefetch" href="/assets/js/225.46e90caa.js"><link rel="prefetch" href="/assets/js/226.63ed554a.js"><link rel="prefetch" href="/assets/js/227.7fafc4da.js"><link rel="prefetch" href="/assets/js/228.7706dc54.js"><link rel="prefetch" href="/assets/js/229.842a1964.js"><link rel="prefetch" href="/assets/js/23.87e7e45e.js"><link rel="prefetch" href="/assets/js/230.ddc0f55a.js"><link rel="prefetch" href="/assets/js/231.e72fa0a7.js"><link rel="prefetch" href="/assets/js/232.e15e10a1.js"><link rel="prefetch" href="/assets/js/233.9001d006.js"><link rel="prefetch" href="/assets/js/234.c55b49d9.js"><link rel="prefetch" href="/assets/js/235.da1bf5f9.js"><link rel="prefetch" href="/assets/js/236.9efb932c.js"><link rel="prefetch" href="/assets/js/237.67412574.js"><link rel="prefetch" href="/assets/js/238.24ef619f.js"><link rel="prefetch" href="/assets/js/239.1f2a6298.js"><link rel="prefetch" href="/assets/js/24.5aa30e8d.js"><link rel="prefetch" href="/assets/js/240.9c9279b1.js"><link rel="prefetch" href="/assets/js/241.695630cd.js"><link rel="prefetch" href="/assets/js/242.891e7aef.js"><link rel="prefetch" href="/assets/js/243.edd26862.js"><link rel="prefetch" href="/assets/js/244.ed576d71.js"><link rel="prefetch" href="/assets/js/245.d10042cf.js"><link rel="prefetch" href="/assets/js/246.d57006a7.js"><link rel="prefetch" href="/assets/js/247.b2d6742e.js"><link rel="prefetch" href="/assets/js/248.8b56d853.js"><link rel="prefetch" href="/assets/js/249.b8fc1805.js"><link rel="prefetch" href="/assets/js/25.5c7b2cfe.js"><link rel="prefetch" href="/assets/js/250.1aad43ae.js"><link rel="prefetch" href="/assets/js/251.be9db929.js"><link rel="prefetch" href="/assets/js/252.afedca09.js"><link rel="prefetch" href="/assets/js/253.c6e86855.js"><link rel="prefetch" href="/assets/js/254.90b4f52a.js"><link rel="prefetch" href="/assets/js/255.227c9c47.js"><link rel="prefetch" href="/assets/js/256.fe3714d4.js"><link rel="prefetch" href="/assets/js/257.3e5db4f7.js"><link rel="prefetch" href="/assets/js/258.29013d06.js"><link rel="prefetch" href="/assets/js/259.e9af4b51.js"><link rel="prefetch" href="/assets/js/26.5a8e32e6.js"><link rel="prefetch" href="/assets/js/260.9555612d.js"><link rel="prefetch" href="/assets/js/261.e8e200a0.js"><link rel="prefetch" href="/assets/js/262.0f393806.js"><link rel="prefetch" href="/assets/js/263.42b99650.js"><link rel="prefetch" href="/assets/js/264.5e36cccd.js"><link rel="prefetch" href="/assets/js/265.e7759e0e.js"><link rel="prefetch" href="/assets/js/266.2bce58fa.js"><link rel="prefetch" href="/assets/js/267.6e2a5a40.js"><link rel="prefetch" href="/assets/js/27.997b1485.js"><link rel="prefetch" href="/assets/js/28.ef6638c6.js"><link rel="prefetch" href="/assets/js/29.c9d728b9.js"><link rel="prefetch" href="/assets/js/3.dc3407e1.js"><link rel="prefetch" href="/assets/js/30.d873fb03.js"><link rel="prefetch" href="/assets/js/31.2bf741ce.js"><link rel="prefetch" href="/assets/js/32.551ac32b.js"><link rel="prefetch" href="/assets/js/33.b6573b5c.js"><link rel="prefetch" href="/assets/js/34.b46900a8.js"><link rel="prefetch" href="/assets/js/35.f131466c.js"><link rel="prefetch" href="/assets/js/36.89942ede.js"><link rel="prefetch" href="/assets/js/37.0e54922b.js"><link rel="prefetch" href="/assets/js/38.36f714a1.js"><link rel="prefetch" href="/assets/js/39.2256d2d3.js"><link rel="prefetch" href="/assets/js/4.43d53c19.js"><link rel="prefetch" href="/assets/js/40.784c879e.js"><link rel="prefetch" href="/assets/js/41.8bac5a7b.js"><link rel="prefetch" href="/assets/js/42.b6e7fc8b.js"><link rel="prefetch" href="/assets/js/43.ab92dcea.js"><link rel="prefetch" href="/assets/js/44.666a8d67.js"><link rel="prefetch" href="/assets/js/45.23a7d54d.js"><link rel="prefetch" href="/assets/js/46.c90bff29.js"><link rel="prefetch" href="/assets/js/47.b109dec7.js"><link rel="prefetch" href="/assets/js/48.7f766765.js"><link rel="prefetch" href="/assets/js/49.0a8e763d.js"><link rel="prefetch" href="/assets/js/5.b6321aed.js"><link rel="prefetch" href="/assets/js/50.686d1521.js"><link rel="prefetch" href="/assets/js/51.9936e373.js"><link rel="prefetch" href="/assets/js/52.f0b789de.js"><link rel="prefetch" href="/assets/js/53.5438164d.js"><link rel="prefetch" href="/assets/js/54.ec6f1f74.js"><link rel="prefetch" href="/assets/js/55.002caceb.js"><link rel="prefetch" href="/assets/js/56.d7896533.js"><link rel="prefetch" href="/assets/js/57.560f886c.js"><link rel="prefetch" href="/assets/js/58.ede39d55.js"><link rel="prefetch" href="/assets/js/59.f8e25f0e.js"><link rel="prefetch" href="/assets/js/6.8dc86351.js"><link rel="prefetch" href="/assets/js/60.16e85fb0.js"><link rel="prefetch" href="/assets/js/61.c4a68cdb.js"><link rel="prefetch" href="/assets/js/62.b8285ec7.js"><link rel="prefetch" href="/assets/js/63.cea2c4d9.js"><link rel="prefetch" href="/assets/js/64.33d06366.js"><link rel="prefetch" href="/assets/js/65.7dacc788.js"><link rel="prefetch" href="/assets/js/66.1c982721.js"><link rel="prefetch" href="/assets/js/67.5509334e.js"><link rel="prefetch" href="/assets/js/68.f9deb190.js"><link rel="prefetch" href="/assets/js/69.fd052a09.js"><link rel="prefetch" href="/assets/js/7.4de4dc57.js"><link rel="prefetch" href="/assets/js/70.b36ecec1.js"><link rel="prefetch" href="/assets/js/71.09472ede.js"><link rel="prefetch" href="/assets/js/72.7fc03c28.js"><link rel="prefetch" href="/assets/js/73.1df4ed7b.js"><link rel="prefetch" href="/assets/js/74.eef842dd.js"><link rel="prefetch" href="/assets/js/75.a4642706.js"><link rel="prefetch" href="/assets/js/76.2921120f.js"><link rel="prefetch" href="/assets/js/77.8959d3b8.js"><link rel="prefetch" href="/assets/js/78.15af67c9.js"><link rel="prefetch" href="/assets/js/79.ca2b3995.js"><link rel="prefetch" href="/assets/js/80.86253068.js"><link rel="prefetch" href="/assets/js/81.4dfb5100.js"><link rel="prefetch" href="/assets/js/82.40f05690.js"><link rel="prefetch" href="/assets/js/83.ae59f017.js"><link rel="prefetch" href="/assets/js/84.a16c2086.js"><link rel="prefetch" href="/assets/js/85.78764153.js"><link rel="prefetch" href="/assets/js/86.6da75781.js"><link rel="prefetch" href="/assets/js/87.9093c83e.js"><link rel="prefetch" href="/assets/js/88.1b71ff61.js"><link rel="prefetch" href="/assets/js/89.c3298594.js"><link rel="prefetch" href="/assets/js/90.dbab72f7.js"><link rel="prefetch" href="/assets/js/91.201c3950.js"><link rel="prefetch" href="/assets/js/92.23d20e66.js"><link rel="prefetch" href="/assets/js/93.35dc98bf.js"><link rel="prefetch" href="/assets/js/94.da768453.js"><link rel="prefetch" href="/assets/js/95.9767a2ff.js"><link rel="prefetch" href="/assets/js/96.890fcdc4.js"><link rel="prefetch" href="/assets/js/97.4bdcd3d5.js"><link rel="prefetch" href="/assets/js/98.972a16fd.js"><link rel="prefetch" href="/assets/js/99.44f9b5d3.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.a900b7e8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8f3dca9f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="Front-End-Basics" class="logo"> <span class="site-name can-hide">Front-End-Basics</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/article/" class="nav-link">
  捡贝壳
</a></div> <a href="https://github.com/qiqihaobenben/Front-End-Basics" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/article/" class="nav-link">
  捡贝壳
</a></div> <a href="https://github.com/qiqihaobenben/Front-End-Basics" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>基础篇</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/javascript/utility/lexical-grammar.html" class="sidebar-link">JavaScript 词法</a></li><li><a href="/javascript/utility/syntax.html" class="sidebar-link">JavaScript 语法</a></li><li><a href="/javascript/ES6/block.html" class="sidebar-link">[ES6]由块级作用域引出的一场变革</a></li><li><a href="/javascript/utility/javascript-type.html" class="sidebar-link">JavaScript 数据类型（运行时）</a></li><li><a href="/javascript/utility/javascript-function.html" class="sidebar-link">JavaScript 函数</a></li><li><a href="/javascript/utility/javascript-object.html" class="sidebar-link">JavaScript 对象相关</a></li><li><a href="/javascript/utility/javascript-asynchronous.html" class="sidebar-link">JavaScript 异步</a></li><li><a href="/javascript/ES6/promise.html" class="sidebar-link">JavaScript Promise 详解</a></li><li><a href="/javascript/ES6/async.html" class="sidebar-link">[译]async 的异步操作模式</a></li><li><a href="/javascript/utility/javascript-runing.html" class="sidebar-link">JavaScript 引擎的执行原理</a></li><li><a href="/javascript/utility/memory.html" class="sidebar-link">JavaScript 内存管理和垃圾回收</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>应用篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构和算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>网络请求</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="正则表达式"><a href="#正则表达式" class="header-anchor">#</a> 正则表达式</h1> <h2 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h2> <h3 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h3> <p>正则表达式（Regular Expression），简称 regex，是一种特殊的文本模式（特定的规则、模板或结构），用于在<strong>字符串</strong>中搜索、匹配和替换文本。</p> <h3 id="正则表达式在计算机领域的发展"><a href="#正则表达式在计算机领域的发展" class="header-anchor">#</a> 正则表达式在计算机领域的发展</h3> <h4 id="发展史"><a href="#发展史" class="header-anchor">#</a> 发展史</h4> <ul><li>20 世纪 40 年代，两个神经生理学家研究出了一种用数学方式来描述神经网络的方法，可以将神经系统中的神经元描述成小而简单的自动控制元。</li> <li>20 世纪 50 年代，Stephen Kleene 在以上两位的基础上发表了《神经网络事件表示法和有穷自动机》 论文。这篇论文描述了一种叫做 &quot;正则集合（Regular Sets）&quot; 的数学符号，引入了正则表达式的概念。</li> <li>20 世纪 60 年代，Unix 之父 Ken Thompson 发表了 《正则表达式搜索算法》 论文。并应用在文本搜索工具 grep 中。</li> <li>20 世纪 70 年代，由于 grep 支持的功能不多，出现了 egrep 、 awk 、 lex 、 sed 等，每个程序所支持的正则表达式都有差别。</li> <li>20 世纪 80 年代，<code>POSIX</code>（Portable Operating System Interface）标准公布，其中就包含不同操作系统都需要遵守的正则表达式规范。</li> <li>20 世纪 90 年代，在 80 年代发布的 Perl 编程语言，引入了正则表达式功能，并随着语言的发展越来越强大，为了把 Perl 语言的正则表达式功能移植到其他语言中，诞生了开源项目 <code>PCRE</code>（Perl Compatiable Regular Expressions）</li></ul> <h4 id="正则表达式规范分类"><a href="#正则表达式规范分类" class="header-anchor">#</a> 正则表达式规范分类</h4> <p>遵循 POSIX 规则的正则表达式，称为 POSIX 派系的正则表达式。Unix 系统或类 Unix 系统上的大部分工具，如 grep 、sed 、awk 等都属于 POSIX 派系。</p> <p>遵循 PCRE 规范的正则表达式，成为 PCRE 派系的正则表达式。现代编程语言如 Python ， Ruby ， PHP ， C / C++ ， Java 等正则表达式，大部分都属于 PCRE 派系，或参照 PCRE 派系发展而来。</p> <h5 id="posix-派系分为两个标准"><a href="#posix-派系分为两个标准" class="header-anchor">#</a> POSIX 派系分为两个标准</h5> <ul><li>BRE 标准（Basic Regular Expression 基本正则表达式）</li> <li>ERE 标准（Extended Regular Expression 扩展正则表达式）</li></ul> <h5 id="pcre-跟-posix-相比有哪些优势"><a href="#pcre-跟-posix-相比有哪些优势" class="header-anchor">#</a> PCRE 跟 POSIX 相比有哪些优势？</h5> <p>PCRE 使用起来更加易用简洁（不需要转义，有更简洁字符组），功能更加丰富（非捕获组，环顾断言，非贪婪）。如果没有特殊原因，应尽可能使用 PCRE 派系，让正则匹配的结果更符合我们预期。</p> <h5 id="不同正则表达式规格和引擎的区别概览"><a href="#不同正则表达式规格和引擎的区别概览" class="header-anchor">#</a> 不同正则表达式规格和引擎的区别概览</h5> <p><a href="https://deerchao.cn/tutorials/regex/diffs.html" target="_blank" rel="noopener noreferrer">正则表达式引擎/风味对比<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="基础语法"><a href="#基础语法" class="header-anchor">#</a> 基础语法</h2> <h3 id="创建方式"><a href="#创建方式" class="header-anchor">#</a> 创建方式</h3> <h4 id="regexp-字面量"><a href="#regexp-字面量" class="header-anchor">#</a> RegExp 字面量</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">hello</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span>
</code></pre></div><h4 id="regexp-构造函数"><a href="#regexp-构造函数" class="header-anchor">#</a> RegExp() 构造函数</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">)</span>
</code></pre></div><h5 id="new-regexp-创建字面量形式"><a href="#new-regexp-创建字面量形式" class="header-anchor">#</a> new RegExp() 创建字面量形式</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">xyz</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">)</span>
<span class="token comment">// 等价于</span>
<span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">xyz</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span>
</code></pre></div><p>其实还有一种形式的字面量 <code>new RegExp(/xyz/i)</code> ，注意第一个参数不是字符串，而是正则表达式字面量。</p> <p>这样的写法就会存在正则表达式字面量中修饰符和 RegExp 构造函数第二个参数冲突的情况。在 ES5 中不允许此时使用第二个参数添加修饰符，否则会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>var regex = new RegExp(/xyz/, 'i');
// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another
</code></pre></div><p>ES6 改变了这种行为。如果 RegExp 构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p> <div class="language- extra-class"><pre class="language-text"><code>new RegExp(/abc/ig).flags // gi
new RegExp(/abc/ig, 'i').flags // i ，原有正则对象的修饰符是ig，它会被第二个参数i覆盖
</code></pre></div><h4 id="字面量和构造函数的区别"><a href="#字面量和构造函数的区别" class="header-anchor">#</a> 字面量和构造函数的区别</h4> <ul><li>反斜杠 <code>\</code> 进行转义时，字面量语法需要一个反斜杠 <code>\</code> ，而 <code>RegExp</code> 构造函数需要两个反斜杠 <code>\\</code>（因为字符串内部会先转义一次）</li></ul> <p>例如：匹配字符串 <code>1+1=2</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'1+2=3'</span>
<span class="token keyword">const</span> reg1 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">1\+2=3</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">const</span> reg2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">'1\\+2=3'</span><span class="token punctuation">)</span> <span class="token comment">// 两个反斜杠</span>
reg1<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>
reg2<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>
</code></pre></div><p>以下是常见需要转义的字符：</p> <ol><li>反斜杠 (<code>\</code>)：用于开始一个转义序列。</li> <li>点 (<code>.</code>)：匹配除换行符之外的任何单个字符。</li> <li>星号 (<code>*</code>)：表示零次或多次匹配前面的元素。</li> <li>加号 (<code>+</code>)：表示一次或多次匹配前面的元素。</li> <li>问号 (<code>?</code>)：表示零次或一次匹配前面的元素；也用于表示非贪婪匹配。</li> <li>圆括号 (<code>(</code> 和 <code>)</code>)：用于分组。</li> <li>方括号 (<code>[</code> 和 <code>]</code>)：用于定义字符集。</li> <li>花括号 (<code>{</code> 和 <code>}</code>)：用于指定数量限定符。</li> <li>竖线 (<code>|</code>)：表示选择（或）。</li> <li>脱字符 (<code>^</code>)：表示行的开始；在字符集中用来表示否定。</li> <li>美元符号 (<code>$</code>)：表示行的结束。</li> <li>正斜杠 (<code>/</code>)：如果你在 <code>/</code> 之间使用正则表达式，也需要转义。</li></ol> <ul><li><p>字面量语法在性能方面更有优势，如果正则表达式在代码中是固定的，不需要动态生成，那么使用字面量语法（如 <code>/pattern/flags</code>）通常更高效，因为 JavaScript 引擎会在脚本加载时编译它们。相比之下，使用 <code>RegExp</code> 构造函数创建的正则表达式可能会在每次使用时都重新编译。</p></li> <li><p>字面量语法更简洁方便和直观</p></li> <li><p><code>RegExp</code> 构造函数的最大的优势是能够动态地生成正则表达式。你可以在运行时根据变量或表达式构造一个正则表达式，这在使用字面量形式时做不到。</p></li></ul> <h3 id="字面量字符"><a href="#字面量字符" class="header-anchor">#</a> 字面量字符</h3> <p>如果在正则表达式中，某个字符只表示它字面的含义，那他们就叫做字面量字符（Literal Characters）</p> <p>例如下面代码中正则表达式的 d、 o 、g 三个字符，就是字面量字符</p> <div class="language- extra-class"><pre class="language-text"><code>/dog/.test('old dog') // true
</code></pre></div><h3 id="元字符"><a href="#元字符" class="header-anchor">#</a> 元字符</h3> <p>有一部分字符有特殊含义，不代表字面的意思，这些字符就是元字符（Meta Characters），元字符有以下几种：</p> <ol><li>反斜杠 (<code>\</code>)：用于开始一个转义序列。</li> <li>点 (<code>.</code>)：匹配除换行符之外的任何单个字符。</li> <li>星号 (<code>*</code>)：表示零次或多次匹配前面的元素。</li> <li>加号 (<code>+</code>)：表示一次或多次匹配前面的元素。</li> <li>问号 (<code>?</code>)：表示零次或一次匹配前面的元素；也用于表示非贪婪匹配。</li> <li>圆括号 (<code>(</code> 和 <code>)</code>)：用于分组。</li> <li>方括号 (<code>[</code> 和 <code>]</code>)：用于定义字符集。</li> <li>花括号 (<code>{</code> 和 <code>}</code>)：用于指定数量限定符。</li> <li>竖线 (<code>|</code>)：表示选择（或）。</li> <li>脱字符 (<code>^</code>)：表示行的开始；在字符集中用来表示否定。</li> <li>美元符号 (<code>$</code>)：表示行的结束。</li></ol> <h3 id="转义符"><a href="#转义符" class="header-anchor">#</a> 转义符</h3> <p>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配字符串 <code>+</code>，就要写成 <code>\+</code>。</p> <p>正则表达式中，需要反斜杠转义的，一共有 12 个字符：反斜杠 (<code>\</code>)、点 (<code>.</code>)、星号 (<code>*</code>)、加号 (<code>+</code>)、问号 (<code>?</code>)、圆括号 (<code>(</code> 和 <code>)</code>)、方括号 (<code>[</code> 和 <code>]</code>)、花括号 (<code>{</code> 和 <code>}</code>)、竖线 (<code>|</code>)、脱字符 (<code>^</code>)、美元符号 (<code>$</code>)。<strong>需要特别注意的是，如果使用 RegExp 构造函数生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</strong></p> <h5 id="怎么理解因为字符串内部会先转义一次"><a href="#怎么理解因为字符串内部会先转义一次" class="header-anchor">#</a> 怎么理解因为字符串内部会先转义一次</h5> <p>在字符串内部，反斜杠也是转义字符，所以它需要先被反斜杠转义一次。</p> <div class="language- extra-class"><pre class="language-text"><code>var str = 'ab\c\*'
var str1 = 'ab\\c\\*'
console.log(str) // abc* 结果是不带转译符的
console.log(str1) // ab\c\*
</code></pre></div><h3 id="点字符"><a href="#点字符" class="header-anchor">#</a> 点字符（<code>.</code>）</h3> <p>点字符（<code>.</code>）匹配除回车（<code>\r</code>）、换行(<code>\n</code>) 、行分隔符（<code>\u2028</code>）和段分隔符（<code>\u2029</code>）以外的所有字符。</p> <div class="language- extra-class"><pre class="language-text"><code>/c.t/.test('cat') // true
</code></pre></div><p><strong>注意：对于码点大于 0xFFFF 的 Unicode 字符，点字符不能正确匹配，会认为这是两个字符。</strong></p> <h3 id="选择符"><a href="#选择符" class="header-anchor">#</a> 选择符（<code>|</code>）</h3> <p>竖线符号（<code>|</code>）在正则表达式中表示“或关系”（OR）。</p> <h4 id="选择符会包括它前后的多个字符-注意-是多个字符"><a href="#选择符会包括它前后的多个字符-注意-是多个字符" class="header-anchor">#</a> 选择符会包括它前后的多个字符，注意，是多个字符</h4> <p>比如/ab|cd/指的是匹配 ab 或者 cd，而不是指匹配 b 或者 c</p> <div class="language- extra-class"><pre class="language-text"><code>'abd'.match(/ab|cd/g) // 返回 ['ab']
</code></pre></div><p>如果想要修改成单个字符，可以使用圆括号</p> <div class="language- extra-class"><pre class="language-text"><code>'abd'.match(/a(b|c)d/g) // 返回 ['abd']
</code></pre></div><h3 id="锚字符"><a href="#锚字符" class="header-anchor">#</a> 锚字符</h3> <p>锚字符包含两个位置字符和两个位置预定义模式</p> <ul><li><code>^</code>：匹配字符串的开头，在多行检索中，匹配一行的开头</li> <li><code>$</code>：匹配字符串的结尾，在多行检索中，匹配一行的结尾</li> <li><code>\b</code>：匹配词的边界</li> <li><code>\B</code>：匹配非词边界，即在词的内部</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// \b 的例子
/\bworld/.test('hello world') // true
/\bworld/.test('hello-world') // true
/\bworld/.test('helloworld') // false

// \B 的例子
/\Bworld/.test('hello-world') // false
/\Bworld/.test('helloworld') // true
</code></pre></div><p>上面代码中，<code>\b</code> 表示词的边界，所以 world 的词首必须独立（词尾是否独立未指定），才会匹配。同理，<code>\B</code> 表示非词的边界，只有 world 的词首不独立，才会匹配。</p> <p>其实零宽正向先行断言 <code>(?=)</code> 和零宽负向先行断言 <code>(?!)</code> 也属于锚字符的范畴。</p> <h3 id="量词"><a href="#量词" class="header-anchor">#</a> 量词</h3> <p>量词用来描述前面的相邻的（单个或一组）字符匹配规则出现的次数</p> <ul><li><code>{n,m}</code>：匹配前一项至少 n 次，但不能超过 m 次</li> <li><code>{n,}</code>：匹配前一项 n 次及以上</li> <li><code>{n}</code>：匹配前一项 n 次</li> <li><code>?</code>：匹配前一项 0 次或 1 次，也就是说前一项是可选的，等价于 <code>{0,1}</code></li> <li><code>+</code>：匹配前一项 1 次或多次，等价于 <code>{1,}</code></li> <li><code>*</code>：匹配前一项 0 次或多次，等价于 <code>{0,}</code></li></ul> <h3 id="预定义模式"><a href="#预定义模式" class="header-anchor">#</a> 预定义模式</h3> <ul><li><code>\d</code>：匹配 0-9 之间的任一数字，相当于[0-9]</li> <li><code>\D</code>：匹配所有 0-9 以外的字符，相当于[^0-9]</li> <li><code>\w</code>：匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]</li> <li><code>\W</code>：除所有字母、数字和下划线以外的字符，相当于[^a-za-z0-9_]</li> <li><code>\s</code>：匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]</li> <li><code>\S</code>：匹配非空格的字符，相当于[^ \t\r\n\v\f]</li> <li><code>\b</code>：匹配词的边界（边界包括：空格、起始、结束）</li> <li><code>\B</code>：匹配非词边界，即在词的内部</li></ul> <p><strong>扩展：跟 <code>[^]</code> 类似，<code>[\S\s]</code> 指代一切字符。</strong></p> <h3 id="字符类"><a href="#字符类" class="header-anchor">#</a> 字符类</h3> <p>字符类（class）又被称为 字符组 或 字符集合，表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如 <code>[xyz]</code> 表示 x、y、z 之中任选一个匹配</p> <h4 id="方括号内的脱字符"><a href="#方括号内的脱字符" class="header-anchor">#</a> 方括号内的脱字符（<code>^</code>）</h4> <p><code>^</code> 在方括号外用来匹配行的开头，但是在方括号内（开头第一个位置），则表示除了字符类之中的字符，其他字符都可以匹配。</p> <div class="language- extra-class"><pre class="language-text"><code>//字符串bbc news包含a、b、c以外的其他字符，所以返回true
/[^abc]/.test('bbc news') // true

//字符串bbc不包含a、b、c以外的其他字符，所以返回false
/[^abc]/.test('bcc')
</code></pre></div><p><strong>注意：如果方括号内没有其他字符，即只有<code>[^]</code>，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（<code>.</code>）是不包括换行符的。</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var s = 'Please yes\nmake my day!';

s.match(/yes.*day/) // null
s.match(/yes[^]*day/) // [ 'yes\nmake my day']
</code></pre></div><p><strong>注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。</strong></p> <div class="language- extra-class"><pre class="language-text"><code>/[a^b]/.test('ccc^')// true
</code></pre></div><h4 id="方括号内的连字符"><a href="#方括号内的连字符" class="header-anchor">#</a> 方括号内的连字符（<code>-</code>）</h4> <p><code>-</code> 在方括号外匹配普通连字符号，但是在方括号内（不在开头），则表示字符的连续范围。比如，<code>[abc]</code> 可以写成 <code>[a-c]</code>，<code>[0123456789]</code> 可以写成 <code>[0-9]</code>，同理<code>[A-Z]</code>表示 26 个大写字母。</p> <div class="language- extra-class"><pre class="language-text"><code>/a-z/.test('b') // false
/[a-z]/.test('b') // true
</code></pre></div><p>以下都是合法的字符类简写形式</p> <div class="language- extra-class"><pre class="language-text"><code>[0-9,]
[0-9a-fA-F]
[a-zA-Z0-9-] // 注意：最后一个 - ，只是代表普通连字符号
[1-31] //注意：不代表1到31，只代表1到3
</code></pre></div><p>连字符还可以用来指定 Unicode 字符的范围</p> <div class="language- extra-class"><pre class="language-text"><code>var str = &quot;\u0130\u0131\u0132&quot;;
/[\u0128-\uFFFF]/.test(str)
// true
</code></pre></div><p><strong>注意：不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符</strong></p> <p>最典型的例子就是<code>[A-z]</code>，表面上它是选中从大写的 A 到小写的 z 之间 52 个字母，但是由于在 ASCII 编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果。</p> <div class="language- extra-class"><pre class="language-text"><code>// 由于反斜杠（’\‘）的ASCII码在大写字母与小写字母之间，结果会被选中
/[A-z]/.test('\\') // true
</code></pre></div><h5 id="如果想让方括号中的连字符匹配一个普通的连字符-连字符必须放在字符组的开头-保证它是一个普通字符。"><a href="#如果想让方括号中的连字符匹配一个普通的连字符-连字符必须放在字符组的开头-保证它是一个普通字符。" class="header-anchor">#</a> 如果想让方括号中的连字符匹配一个普通的连字符，连字符必须放在字符组的开头，保证它是一个普通字符。</h5> <h4 id="方括号内的其他需要转义的元字符"><a href="#方括号内的其他需要转义的元字符" class="header-anchor">#</a> 方括号内的其他需要转义的元字符</h4> <p>需要转义的元字符，除了<code>\</code> 需要转义，不能直接写在方括号中外， <code>. + ? * { } / ( ) $ | [ ]</code>在方括号内只是匹配普通字符</p> <div class="language- extra-class"><pre class="language-text"><code>/[.+?*{}/()$|]/.test('*') // true
</code></pre></div><h3 id="组匹配"><a href="#组匹配" class="header-anchor">#</a> 组匹配</h3> <p>组匹配相关的有分组字符、非捕获分组、引用字符</p> <h4 id="分组字符"><a href="#分组字符" class="header-anchor">#</a> 分组字符</h4> <p>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。</p> <h5 id="可通过-、-、-和-竖线-等符号修饰"><a href="#可通过-、-、-和-竖线-等符号修饰" class="header-anchor">#</a> 可通过 <code>*</code>、<code>+</code>、<code>?</code> 和 竖线<code>|</code> 等符号修饰</h5> <div class="language- extra-class"><pre class="language-text"><code>/hi+/.exec('hihi') // 只能匹配 'hi'
/(hi)+/.exec('hihi') // 可以匹配 'hihi'
</code></pre></div><h5 id="可以进行分组捕获"><a href="#可以进行分组捕获" class="header-anchor">#</a> 可以进行分组捕获</h5> <div class="language- extra-class"><pre class="language-text"><code>// 正则表达式/(.)b(.)/一共使用两个括号，第一个括号捕获a，第二个括号捕获c。
'abcabc'.match(/(.)b(.)/) // // ['abc', 'a', 'c']
</code></pre></div><p><strong>注意：使用分组捕获时，不宜同时使用 <code>g</code> 修饰符，否则 <code>match</code> 方法不会捕获分组的内容。</strong></p> <div class="language- extra-class"><pre class="language-text"><code>'abcabc'.match(/(.)b(.)/g) // ['abc', 'abc']
</code></pre></div><p>上面代码使用带 <code>g</code> 修饰符的正则表达式，结果 <code>match</code> 方法只捕获了匹配整个表达式的部分。这时必须使用正则表达式的 <code>exec</code> 方法，配合循环，才能读到每一轮匹配的组捕获。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'abcabc'</span>
<span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(.)b(.)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> result <span class="token operator">=</span> reg<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">)</span> <span class="token keyword">break</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]</span>
<span class="token comment">// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]</span>
</code></pre></div><h5 id="可以跟引用字符配合使用"><a href="#可以跟引用字符配合使用" class="header-anchor">#</a> 可以跟引用字符配合使用</h5> <div class="language- extra-class"><pre class="language-text"><code>/(.)b(.)\1b\2/.test(&quot;abcabc&quot;)
</code></pre></div><p>上面的代码中，\1 表示第一个括号匹配的内容（即 a），\2 表示第二个括号匹配的内容（即 c）</p> <h5 id="非捕获分组"><a href="#非捕获分组" class="header-anchor">#</a> 非捕获分组</h5> <p><code>(?:x)</code> 称为非捕获组（Non-capturing group），表示不在捕获分组返回该组匹配的内容，即匹配的捕获分组的结果中不计入该分组的数据。</p> <p>非捕获组的作用可能就是需要分组匹配，但是不需要在捕获分组中展示出来的情况。</p> <div class="language- extra-class"><pre class="language-text"><code>// 一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的捕获分组的结果中没有第一个括号，只有第二个括号匹配的内容。
'abc'.match(/(?:.)b(.)/); //
</code></pre></div><p><strong>注意：非捕获分组是不计入引用字符的编码的</strong></p> <h5 id="引用字符"><a href="#引用字符" class="header-anchor">#</a> 引用字符</h5> <p>正则表达式内部，还可以用 <code>\n</code> 引用括号匹配的内容，n 是从 1 开始的自然数，表示对应顺序的括号。</p> <div class="language- extra-class"><pre class="language-text"><code>// \1表示第一个括号匹配的内容（即a），\2表示第二个括号匹配的内容（即c）
/(.)b(.)\1b\2/.test(&quot;abcabc&quot;) // true

// 引用字符的顺序可以按照实际情况调整
/y(..)(.)\2\1/.test('yabccab') // true

// 括号还可以嵌套，\1指向外层括号，\2指向内层括号
/y((..)\2)\1/.test('yabababab') // true
</code></pre></div><h5 id="具名分组-es2018"><a href="#具名分组-es2018" class="header-anchor">#</a> 具名分组（ES2018）</h5> <p>ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</p> <p>语法是：“具名组匹配” 在圆括号内部，模式的头部添加 “问号 + 尖括号 + 组名”，例如 <code>?&lt;year&gt;</code></p> <ul><li>捕获分组的改变</li></ul> <p>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如 <code>matchObj[1]</code>）引用，要是组的顺序变了，引用的时候就必须修改序号。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token constant">RE_DATE</span> <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\d{4})-(\d{2})-(\d{2})</span><span class="token regex-delimiter">/</span></span>

<span class="token keyword">const</span> matchObj <span class="token operator">=</span> <span class="token constant">RE_DATE</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'1999-12-31'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> year <span class="token operator">=</span> matchObj<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 1999</span>
<span class="token keyword">const</span> month <span class="token operator">=</span> matchObj<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token comment">// 12</span>
<span class="token keyword">const</span> day <span class="token operator">=</span> matchObj<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token comment">// 31</span>
</code></pre></div><p>具名组匹配可以在 <code>exec</code> 方法返回结果的 <code>groups</code> 属性上引用该组名。同时，数字序号（<code>matchObj[1]</code>）依然有效。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token constant">RE_DATE</span> <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})</span><span class="token regex-delimiter">/</span></span>

<span class="token keyword">const</span> matchObj <span class="token operator">=</span> <span class="token constant">RE_DATE</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'1999-12-31'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> year <span class="token operator">=</span> matchObj<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>year <span class="token comment">// &quot;1999&quot;</span>
<span class="token keyword">const</span> month <span class="token operator">=</span> matchObj<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>month <span class="token comment">// &quot;12&quot;</span>
<span class="token keyword">const</span> day <span class="token operator">=</span> matchObj<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>day <span class="token comment">// &quot;31&quot;</span>
</code></pre></div><p>具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。</p> <p>如果具名组没有匹配，那么对应的 <code>groups</code> 对象属性会是 <code>undefined</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token constant">RE_OPT_A</span> <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^(?&lt;as&gt;a+)?$</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">const</span> matchObj <span class="token operator">=</span> <span class="token constant">RE_OPT_A</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>

matchObj<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>as <span class="token comment">// undefined</span>
<span class="token string">'as'</span> <span class="token keyword">in</span> matchObj<span class="token punctuation">.</span>groups <span class="token comment">// true</span>
</code></pre></div><p>上面代码中，具名组 as 没有找到匹配，那么 matchObj.groups.as 属性值就是 undefined，并且 as 这个键名在 groups 是始终存在的。</p> <ul><li>引用字符的改变</li></ul> <p>具名组匹配的引用字符的语法是 <code>\k</code>开始，后面添加“尖括号 + 组名”，例如 <code>\k&lt;first&gt;</code></p> <div class="language- extra-class"><pre class="language-text"><code>/(.)b(.)\1b\2/.test(&quot;abcabc&quot;) // true
/(?&lt;first&gt;.)b(?&lt;last&gt;.)\k&lt;first&gt;b\k&lt;last&gt;/.test(&quot;abcabc&quot;) // true


// 引用字符的顺序可以按照实际情况调整
/y(..)(.)\2\1/.test('yabccab') // true
/y(?&lt;first&gt;..)(?&lt;last&gt;.)\k&lt;last&gt;\k&lt;first&gt;/.test('yabccab') // true
</code></pre></div><ul><li>replace 方法的改变</li></ul> <p>字符串替换时，使用<code>$&lt;组名&gt;</code>引用具名组。</p> <div class="language- extra-class"><pre class="language-text"><code>let re = /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/u;

'2015-01-02'.replace(re, '$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;')
// '02/01/2015'
</code></pre></div><p>replace 方法的第二个参数也可以是函数，具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。</p> <div class="language- extra-class"><pre class="language-text"><code>'2015-01-02'.replace(re, (
   matched, // 整个匹配结果 2015-01-02
   capture1, // 第一个组匹配 2015
   capture2, // 第二个组匹配 01
   capture3, // 第三个组匹配 02
   position, // 匹配开始的位置 0
   S, // 原字符串 2015-01-02
   groups // 具名组构成的一个对象 {year, month, day}
 ) =&gt; {
 let {day, month, year} = groups;
 return `${day}/${month}/${year}`;
});
</code></pre></div><h5 id="实际应用的例子"><a href="#实际应用的例子" class="header-anchor">#</a> 实际应用的例子</h5> <ol><li>匹配网页标签</li></ol> <div class="language- extra-class"><pre class="language-text"><code>let reg = /&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\/\1&gt;/
</code></pre></div><ol start="2"><li>捕获带有属性的标签</li></ol> <div class="language- extra-class"><pre class="language-text"><code>let reg = /&lt;(\w+)\s([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/
</code></pre></div><ol start="3"><li>匹配网址并且捕获 host</li></ol> <div class="language- extra-class"><pre class="language-text"><code>let reg = /^(https?:\/\/)?([\w-]+\.)+[\w-]+/
</code></pre></div><h3 id="修饰符"><a href="#修饰符" class="header-anchor">#</a> 修饰符</h3> <p>修饰符（modifier）表示模式的附加规则，放在正则表达式的最尾部。</p> <p><strong>修饰符可以单个使用，也可以多个一起使用。</strong></p> <div class="language- extra-class"><pre class="language-text"><code>// 单个修饰符
var regex = /test/i;

// 多个修饰符
var regex = /test/ig;
</code></pre></div><h4 id="g-修饰符"><a href="#g-修饰符" class="header-anchor">#</a> <code>g</code> 修饰符</h4> <p><code>g</code> 修饰符表示全局匹配（global）。默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</p> <p>以下代码不含 <code>g</code> 修饰符，每次都是从字符串头部开始匹配。所以，连续做了三次匹配，都返回 true。</p> <div class="language- extra-class"><pre class="language-text"><code>var regex = /b/;
var str = 'abba';

regex.test(str); // true
regex.test(str); // true
regex.test(str); // true
</code></pre></div><p>以下正则模式含有 <code>g</code> 修饰符，<strong>每次都是从上一次匹配成功处，开始向后匹配</strong>。因为字符串 abba 只有两个 b，所以前两次匹配结果为 true，第三次匹配结果为 false。</p> <div class="language- extra-class"><pre class="language-text"><code>var regex = /b/g;
var str = 'abba';

regex.test(str); // true
regex.test(str); // true
regex.test(str); // false
</code></pre></div><h4 id="i-修饰符"><a href="#i-修饰符" class="header-anchor">#</a> <code>i</code> 修饰符</h4> <p><code>i</code> 修饰符表示忽略大小写（ignorecase）。</p> <h4 id="m-修饰符"><a href="#m-修饰符" class="header-anchor">#</a> <code>m</code> 修饰符</h4> <p><code>m</code> 修饰符表示多行模式（multiline），会修改 <code>^</code> 和 <code>$</code> 的行为。</p> <p>默认情况下（即不加 <code>m</code> 修饰符时），<code>^</code> 和 <code>$</code> 匹配字符串的<strong>开始处和结尾处</strong>，加上 <code>m</code> 修饰符以后，<code>^</code> 和 <code>$</code> <strong>还会匹配行首和行尾</strong>，即 <code>^</code> 和 <code>$</code> 会识别换行符（ <code>\n</code> ）。</p> <div class="language- extra-class"><pre class="language-text"><code>/world$/.test('hello world\n') // false
/world$/m.test('hello world\n') // true
/^b/m.test('a\nb') // true 加上m修饰符以后，换行符\n也会被认为是一行的开始
</code></pre></div><h4 id="u-修饰符-es6"><a href="#u-修饰符-es6" class="header-anchor">#</a> <code>u</code> 修饰符（ES6）</h4> <p>含义为“Unicode 模式”，用来正确处理大于\uFFFF 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p> <h5 id="点字符-2"><a href="#点字符-2" class="header-anchor">#</a> 点字符</h5> <p>点（<code>.</code>）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于 <code>0xFFFF</code> 的 Unicode 字符，点字符不能识别，必须加上 <code>u</code> 修饰符。</p> <div class="language- extra-class"><pre class="language-text"><code>var s = '𠮷';

/^.$/.test(s) // false
/^.$/u.test(s) // true
</code></pre></div><h5 id="unicode-字符表示法"><a href="#unicode-字符表示法" class="header-anchor">#</a> Unicode 字符表示法</h5> <p>ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上 <code>u</code> 修饰符，才能识别当中的大括号，否则会被解读为量词。</p> <div class="language- extra-class"><pre class="language-text"><code>/\u{61}/.test('a') // false
/\u{61}/u.test('a') // true
/\u{20BB7}/u.test('𠮷') // true
</code></pre></div><p>上面代码表示，如果不加 <code>u</code> 修饰符，正则表达式无法识别 <code>\u{61}</code> 这种表示法，只会认为这匹配 61 个连续的 u。</p> <h5 id="预定义模式-2"><a href="#预定义模式-2" class="header-anchor">#</a> 预定义模式</h5> <p><code>u</code> 修饰符也影响到预定义模式，能否正确识别码点大于<code>0xFFFF</code>的 Unicode 字符。</p> <div class="language- extra-class"><pre class="language-text"><code>/^\S$/.test('𠮷') // false
/^\S$/u.test('𠮷') // true
</code></pre></div><p>上面代码的 <code>\S</code> 是预定义模式，匹配所有非空白字符。只有加了 <code>u</code> 修饰符，它才能正确匹配码点大于 <code>0xFFFF</code> 的 Unicode 字符。</p> <p>利用这一点，可以写出一个正确返回字符串长度的函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">codePointLength</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> result <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\s\S]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gu</span></span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> result <span class="token operator">?</span> result<span class="token punctuation">.</span>length <span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">'𠮷𠮷'</span>

s<span class="token punctuation">.</span>length <span class="token comment">// 4</span>
<span class="token function">codePointLength</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// 2</span>
</code></pre></div><h5 id="量词-2"><a href="#量词-2" class="header-anchor">#</a> 量词</h5> <p>使用 u 修饰符后，所有量词都会正确识别码点大于 0xFFFF 的 Unicode 字符。</p> <div class="language- extra-class"><pre class="language-text"><code>/a{2}/.test('aa') // true
/a{2}/u.test('aa') // true
/𠮷{2}/.test('𠮷𠮷') // false
/𠮷{2}/u.test('𠮷𠮷') // true
</code></pre></div><h5 id="转义"><a href="#转义" class="header-anchor">#</a> 转义</h5> <p>没有 u 修饰符的情况下，正则中没有定义的转义（如逗号的转义,）无效，而在 u 模式会报错。</p> <div class="language- extra-class"><pre class="language-text"><code>/\,/ // 输出 /\,/
/\,/u // 报错
</code></pre></div><h4 id="y-修饰符-es6"><a href="#y-修饰符-es6" class="header-anchor">#</a> <code>y</code> 修饰符（ES6）</h4> <p>也叫做“粘连”（sticky）修饰符。</p> <p><code>y</code> 修饰符的作用与 <code>g</code> 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，<code>g</code> 修饰符只要剩余位置中存在匹配就可，而 <code>y</code> 修饰符<strong>确保匹配必须从剩余的第一个位置开始</strong>，这也就是“粘连”的涵义。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">'aaa_aa_a'</span>
<span class="token keyword">var</span> r1 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
<span class="token keyword">var</span> r2 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">y</span></span>

r1<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// [&quot;aaa&quot;]</span>
r2<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// [&quot;aaa&quot;]</span>

r1<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// [&quot;aa&quot;]</span>
r2<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// null y修饰符要求匹配必须从头部开始，所以返回null</span>
</code></pre></div><h5 id="实际上-y-修饰符号隐含了头部匹配的标志-。"><a href="#实际上-y-修饰符号隐含了头部匹配的标志-。" class="header-anchor">#</a> 实际上，<code>y</code> 修饰符号隐含了头部匹配的标志 <code>^</code>。</h5> <div class="language- extra-class"><pre class="language-text"><code>/b/y.exec('aba') // null
</code></pre></div><h5 id="单单一个-y-修饰符对-match-方法-只能返回第一个匹配-必须与-g-修饰符联用-才能返回所有匹配。"><a href="#单单一个-y-修饰符对-match-方法-只能返回第一个匹配-必须与-g-修饰符联用-才能返回所有匹配。" class="header-anchor">#</a> 单单一个 <code>y</code> 修饰符对 <code>match</code> 方法，只能返回第一个匹配，必须与 <code>g</code> 修饰符联用，才能返回所有匹配。</h5> <div class="language- extra-class"><pre class="language-text"><code>'a1a2a3'.match(/a\d/y) // [&quot;a1&quot;]
'a1a2a3'.match(/a\d/gy) // [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;]
</code></pre></div><h4 id="s-修饰符-dotall-模式-es2018"><a href="#s-修饰符-dotall-模式-es2018" class="header-anchor">#</a> <code>s</code> 修饰符：<code>dotAll</code> 模式（ES2018）</h4> <p><code>dotAll</code> 模式，即点（dot）代表一切字符。</p> <p>正则表达式中，点（<code>.</code>）是一个特殊字符，代表任意的单个字符，</p> <p>但是有两个例外:</p> <ul><li>一个是四个字节的 UTF-16 字符，这个可以用 <code>u</code> 修饰符解决；</li> <li>另一个是行终止符（line terminator character）。<strong>这个就需要 <code>s</code> 修饰符解决</strong></li></ul> <p>所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。</p> <ul><li>U+000A 换行符（<code>\n</code>）</li> <li>U+000D 回车符（<code>\r</code>）</li> <li>U+2028 行分隔符（line separator）</li> <li>U+2029 段分隔符（paragraph separator）</li></ul> <div class="language- extra-class"><pre class="language-text"><code>/foo.bar/.test('foo\nbar') // false
</code></pre></div><p>上面代码中，因为 <code>.</code> 不匹配 <code>\n</code>，所以正则表达式返回 false。</p> <p>但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。</p> <div class="language- extra-class"><pre class="language-text"><code>/foo[^]bar/.test('foo\nbar') // true
</code></pre></div><p>这种解决方案毕竟不太符合直觉，ES2018 引入 <code>s</code> 修饰符，使得 <code>.</code> 可以匹配任意单个字符。</p> <div class="language- extra-class"><pre class="language-text"><code>/foo.bar/s.test('foo\nbar') // true
</code></pre></div><h5 id="s-修饰符和多行修饰符-m-不冲突-两者一起使用的情况下-匹配所有字符-而-和-匹配每一行的行首和行尾。"><a href="#s-修饰符和多行修饰符-m-不冲突-两者一起使用的情况下-匹配所有字符-而-和-匹配每一行的行首和行尾。" class="header-anchor">#</a> <code>s</code> 修饰符和多行修饰符 <code>m</code> 不冲突，两者一起使用的情况下，<code>.</code> 匹配所有字符，而 <code>^</code>和<code>$</code> 匹配每一行的行首和行尾。</h5> <h4 id="d-修饰符-正则匹配索引"><a href="#d-修饰符-正则匹配索引" class="header-anchor">#</a> <code>d</code> 修饰符：正则匹配索引</h4> <p>ES2022 新增了 d 修饰符，这个修饰符可以让 exec()、match()的返回结果添加 indices 属性，在该属性上面可以拿到匹配的开始位置和结束位置。</p> <p>注意，开始位置包含在匹配结果之中，相当于匹配结果的第一个字符的位置。但是，结束位置不包含在匹配结果之中，是匹配结果的下一个字符。</p> <p>如果正则表达式包含组匹配，那么 indices 属性对应的数组就会包含多个成员，提供每个组匹配的开始位置和结束位置。</p> <div class="language- extra-class"><pre class="language-text"><code>const text = 'zabbcdef';
const re = /ab+(cd)/d;
const result = re.exec(text);

result.indices // [ [ 1, 6 ], [ 4, 6 ] ]
</code></pre></div><p>上面例子中，正则表达式 re 包含一个组匹配(cd)，那么 <code>indices</code> 属性数组就有两个成员，第一个成员是整个匹配结果（abbcd）的开始位置和结束位置，第二个成员是组匹配（cd）的开始位置和结束位置。</p> <p>如果正则表达式包含具名组匹配，indices 属性数组还会有一个 groups 属性。该属性是一个对象，可以从该对象获取具名组匹配的开始位置和结束位置。</p> <div class="language- extra-class"><pre class="language-text"><code>const text = 'zabbcdef';
const re = /ab+(?&lt;Z&gt;cd)/d;
const result = re.exec(text);

result.indices.groups // { Z: [ 4, 6 ] }
</code></pre></div><p>面例子中，exec()方法返回结果的 indices.groups 属性是一个对象，提供具名组匹配 Z 的开始位置和结束位置。</p> <p>如果获取组匹配不成功，indices 属性数组的对应成员则为 undefined，indices.groups 属性对象的对应成员也是 undefined。</p> <h3 id="特殊字符"><a href="#特殊字符" class="header-anchor">#</a> 特殊字符</h3> <p>正则表达式对一些不能打印的特殊字符，提供了表达方法。</p> <ul><li><code>\cX</code>：表示 <code>Ctrl-[X]</code>，其中的 X 是 A-Z 之中任一个英文字母，用来匹配控制字符。</li> <li><code>[\b]</code>：匹配退格键(<code>\u0008</code>)，不要与 <code>\b</code> 混淆</li> <li><code>\n</code>：匹配换行键（\u000A）</li> <li><code>\r</code>：匹配回车键（\u000D）</li> <li><code>\t</code>：匹配制表符 tab（\u0009）</li> <li><code>\v</code>：匹配垂直制表符（\u000B）</li> <li><code>\f</code>：匹配换页符（\u000C）</li> <li><code>\0</code>：匹配 null 字符（\u0000）</li> <li><code>\xhh</code>：匹配一个以两位十六进制数（\x00-\xFF）表示的字符</li> <li><code>\uhhhh</code>：匹配一个以四位十六进制数（\u0000-\uFFFF）表示的 Unicode 字符</li></ul> <p>其中有一些可以进行替代：</p> <ul><li><code>\x0A</code>等价于 <code>\n</code></li> <li><code>\u0009</code>等价于 <code>\t</code></li> <li><code>\cJ</code> 等价于 <code>\n</code></li></ul> <h2 id="属性方法"><a href="#属性方法" class="header-anchor">#</a> 属性方法</h2> <h3 id="regexp-实例方法"><a href="#regexp-实例方法" class="header-anchor">#</a> RegExp 实例方法</h3> <h4 id="regexp-prototype-test"><a href="#regexp-prototype-test" class="header-anchor">#</a> RegExp.prototype.test()</h4> <p>正则实例对象的 <code>test</code> 方法返回一个布尔值，表示当前模式是否能匹配参数字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>/cat/.test('cats and dogs') // true
</code></pre></div><h5 id="正则表达式带有-g-修饰符"><a href="#正则表达式带有-g-修饰符" class="header-anchor">#</a> 正则表达式带有 <code>g</code> 修饰符</h5> <p>如果正则表达式带有 g 修饰符，则每一次 test 方法都从上一次结束的位置开始向后匹配。</p> <div class="language- extra-class"><pre class="language-text"><code>var r = /x/g;
var s = '_x_x';

r.lastIndex // 0
r.test(s) // true

r.lastIndex // 2
r.test(s) // true

r.lastIndex // 4
r.test(s) // false
</code></pre></div><p>带有 <code>g</code> 修饰符时，可以通过正则对象的 <code>lastIndex</code> 属性指定开始搜索的位置。</p> <div class="language- extra-class"><pre class="language-text"><code>var r = /x/g;
var s = '_x_x';

r.lastIndex = 4;
r.test(s) // false lastIndex 属性重置为 0

r.lastIndex // 0
r.test(s) // true
</code></pre></div><p><strong>注意：带有 <code>g</code> 修饰符时，正则表达式内部会记住上一次的 <code>lastIndex</code> 属性，这时不应该更换所要匹配的字符串，否则会有一些难以察觉的错误。</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">bb</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
r<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'bb'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
<span class="token comment">// 由于正则表达式r是从上一次的lastIndex位置开始匹配，导致第二次执行test方法时出现预期以外的结果</span>
r<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'-bb-'</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><p><strong>注意：lastIndex 属性只对同一个正则表达式有效</strong>，所以下面这样写是错误的。</p> <div class="language- extra-class"><pre class="language-text"><code>// 下面代码会导致无限循环，因为while循环的每次匹配条件都是一个新的正则表达式，导致lastIndex属性总是等于0。
var count = 0;
while (/a/g.test('babaa')) count++;

// 如果需要达到预期的效果，可以使用变量存放正则对象
var count = 0;
var reg = /a/g
while (reg.test('babaa')) count++;
</code></pre></div><h5 id="如果正则模式是一个空字符串-则匹配所有字符串。"><a href="#如果正则模式是一个空字符串-则匹配所有字符串。" class="header-anchor">#</a> 如果正则模式是一个空字符串，则匹配所有字符串。</h5> <div class="language- extra-class"><pre class="language-text"><code>new RegExp('').test('abc')
</code></pre></div><p>如果想使用正则表达式字面量模式匹配所有字符串，不能用 <code>//</code>，这个是错误的，需要使用 <code>/(?:)/</code></p> <div class="language- extra-class"><pre class="language-text"><code>/(?:)/.test('abc')

// 因为
new RegExp('').toString() // '/(?:)/'
</code></pre></div><p>另外 <code>/^$/</code> 可以匹配空字符串</p> <div class="language- extra-class"><pre class="language-text"><code>/^$/.test('')
</code></pre></div><h4 id="regexp-prototype-exec"><a href="#regexp-prototype-exec" class="header-anchor">#</a> RegExp.prototype.exec()</h4> <p>正则实例对象的 <code>exec</code> 方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回 <code>null</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>var s = '_x_x';
var r1 = /x/;
var r2 = /y/;

r1.exec(s) // [&quot;x&quot;] 其实返回的对象全部属性时这样的 0:&quot;x&quot; groups:undefined index:1 input:&quot;_x_x&quot; length: 1
r2.exec(s) // null
</code></pre></div><p>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。
第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的 length 属性等于组匹配的数量再加 1。</p> <div class="language- extra-class"><pre class="language-text"><code>var s = '_x_x';
var r = /_(x)/;

r.exec(s) // [&quot;_x&quot;, &quot;x&quot;] length 是 2
</code></pre></div><h5 id="返回值中的-input-属性和-index-属性"><a href="#返回值中的-input-属性和-index-属性" class="header-anchor">#</a> 返回值中的 <code>input</code> 属性和 <code>index</code> 属性</h5> <p>其实返回的数组全部属性时这样的 <code>['_x', 'x', index: 0, input: '_x_x', groups: undefined]</code></p> <ul><li><code>input</code>：整个原字符串。</li> <li><code>index</code>：整个模式匹配成功的开始位置（从 0 开始计数）。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var r = /a(b+)a/;
var arr = r.exec('_abbba_aba_');

arr // [&quot;abbba&quot;, &quot;bbb&quot;]

arr.index // 1
arr.input // &quot;_abbba_aba_&quot;
</code></pre></div><h5 id="如果正则表达式加上-g-修饰符"><a href="#如果正则表达式加上-g-修饰符" class="header-anchor">#</a> 如果正则表达式加上 <code>g</code> 修饰符</h5> <p>如果正则表达式加上 <code>g</code> 修饰符，则可以使用多次 <code>exec</code> 方法，下一次搜索的位置从上一次匹配成功结束的位置开始。</p> <div class="language- extra-class"><pre class="language-text"><code>var reg = /a/g;
var str = 'abc_abc_abc'

while(true) {
  var match = reg.exec(str);
  if (!match) break;
  console.log('#' + match.index + ':' + match[0]);
}
// #0:a
// #4:a
// #8:a
</code></pre></div><h3 id="regexp-对象属性"><a href="#regexp-对象属性" class="header-anchor">#</a> RegExp 对象属性</h3> <h4 id="source"><a href="#source" class="header-anchor">#</a> source</h4> <p>只读字符串，包含正则表达式的文本。</p> <h4 id="global"><a href="#global" class="header-anchor">#</a> global</h4> <p>只读布尔值，是否带修饰符 <code>g</code></p> <h4 id="ignorecase"><a href="#ignorecase" class="header-anchor">#</a> ignoreCase</h4> <p>只读布尔值，是否带修饰符 <code>i</code></p> <h4 id="multiline"><a href="#multiline" class="header-anchor">#</a> multiline</h4> <p>只读布尔值，是否带修饰符 <code>m</code></p> <h4 id="unicode"><a href="#unicode" class="header-anchor">#</a> unicode</h4> <p>ES6 新增，只读布尔值，表示是否设置了 u 修饰符。</p> <h4 id="sticky"><a href="#sticky" class="header-anchor">#</a> sticky</h4> <p>ES6 新增，只读布尔值，表示是否设置了 u 修饰符。</p> <h4 id="dotall"><a href="#dotall" class="header-anchor">#</a> dotall</h4> <p>返回一个布尔值，表示该正则表达式是否处在 dotAll 模式。</p> <h4 id="flags"><a href="#flags" class="header-anchor">#</a> flags</h4> <p>返回一个字符串，包含了已经设置的所有修饰符，按字母排序。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">abc</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gimuy</span></span>

r<span class="token punctuation">.</span>ignoreCase <span class="token comment">// true</span>
r<span class="token punctuation">.</span>global <span class="token comment">// true</span>
r<span class="token punctuation">.</span>multiline <span class="token comment">// true</span>
r<span class="token punctuation">.</span>unicode <span class="token comment">// true</span>
r<span class="token punctuation">.</span>sticky <span class="token comment">// true</span>
r<span class="token punctuation">.</span>flags <span class="token comment">// 'gimuy'</span>
</code></pre></div><h4 id="lastindex"><a href="#lastindex" class="header-anchor">#</a> lastIndex</h4> <p>可读写整数，如果带 g 修饰符，这个属性储存在整个字符串中下一次检索开始的位置，这个属性会被 <code>exec()</code> 和 <code>test()</code> 方法用到。</p> <p>当调用 <code>exec()</code> 或 <code>test()</code> 的正则表达式具有修饰符 <code>g</code> 时，它将把当前正则表达式对象的 <code>lastIndex</code> 属性设置为紧挨着匹配子串的字符位置。如果没发现任何匹配结果，<code>lastIndex</code> 将重置为 <code>0</code>。</p> <h3 id="字符串实例方法"><a href="#字符串实例方法" class="header-anchor">#</a> 字符串实例方法</h3> <h4 id="string-prototype-match"><a href="#string-prototype-match" class="header-anchor">#</a> String.prototype.match()</h4> <p>对字符串进行正则匹配，匹配成功返回一个数组，成员是所有匹配的子字符串，匹配失败返回 null。</p> <div class="language- extra-class"><pre class="language-text"><code>var s = '_x_x';
var r1 = /x/;
var r2 = /y/;

s.match(r1) // [&quot;x&quot;]
s.match(r2) // null
</code></pre></div><h5 id="如果正则表达式带有-g-修饰符"><a href="#如果正则表达式带有-g-修饰符" class="header-anchor">#</a> 如果正则表达式带有 g 修饰符</h5> <p>如果正则表达式带有 <code>g</code> 修饰符，则该方法与正则对象的 <code>exec</code> 方法行为不同，会一次性返回所有匹配成功的结果。</p> <div class="language- extra-class"><pre class="language-text"><code>var s = 'abba';
var r = /a/g;

s.match(r) // [&quot;a&quot;, &quot;a&quot;]
r.exec(s) // [&quot;a&quot;]
</code></pre></div><h5 id="设置正则表达式的-lastindex-属性-对-match-方法无效-匹配总是从字符串的第一个字符开始"><a href="#设置正则表达式的-lastindex-属性-对-match-方法无效-匹配总是从字符串的第一个字符开始" class="header-anchor">#</a> 设置正则表达式的 <code>lastIndex</code> 属性，对 <code>match</code> 方法无效，匹配总是从字符串的第一个字符开始</h5> <div class="language- extra-class"><pre class="language-text"><code>var r = /a|b/g;
r.lastIndex = 7;
'xaxb'.match(r) // ['a', 'b']
r.lastIndex // 0
</code></pre></div><h4 id="string-prototype-matchall"><a href="#string-prototype-matchall" class="header-anchor">#</a> String.prototype.matchAll()</h4> <p>ES2020 增加了 String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个迭代器（Iterator），而不是数组。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> string <span class="token operator">=</span> <span class="token string">'test1test2test3'</span>
<span class="token keyword">const</span> regex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">t(e)(st(\d?))</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> match <span class="token keyword">of</span> string<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span>regex<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]</span>
<span class="token comment">// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]</span>
<span class="token comment">// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span>
</code></pre></div><p>上面代码中，由于 <code>string.matchAll(regex)</code> 返回的是迭代器，所以可以用 <code>for...of</code> 循环取出。相对于返回 <code>match()</code> 数组，返回迭代器的好处在于，如果匹配结果是一个很大的数组，那么迭代器比较节省资源。</p> <p>迭代器转为数组是非常简单的，使用<code>...</code>运算符和 <code>Array.from()</code>方法就可以了。</p> <div class="language- extra-class"><pre class="language-text"><code>// 转为数组的方法一
[...string.matchAll(regex)]

// 转为数组的方法二
Array.from(string.matchAll(regex))
</code></pre></div><h4 id="string-prototype-search"><a href="#string-prototype-search" class="header-anchor">#</a> String.prototype.search()</h4> <p>返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1</p> <div class="language- extra-class"><pre class="language-text"><code>'_x_x'.search(/x/) // 1
</code></pre></div><h4 id="string-prototype-replace"><a href="#string-prototype-replace" class="header-anchor">#</a> String.prototype.replace()</h4> <p>字符串对象的 <code>replace</code> 方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。</p> <h5 id="正则表达式由-g-修饰符"><a href="#正则表达式由-g-修饰符" class="header-anchor">#</a> 正则表达式由 <code>g</code> 修饰符</h5> <p>正则表达式如果不加 <code>g</code> 修饰符，就替换第一个匹配成功的值，如果有替换所有匹配成功的值。</p> <div class="language- extra-class"><pre class="language-text"><code>'aaa'.replace('a', 'b') // &quot;baa&quot;
'aaa'.replace(/a/, 'b') // &quot;baa&quot;
'aaa'.replace(/a/g, 'b') // &quot;bbb&quot;
</code></pre></div><h5 id="第二个参数可以使用美元符号"><a href="#第二个参数可以使用美元符号" class="header-anchor">#</a> 第二个参数可以使用美元符号 <code>$</code></h5> <p><code>replace</code> 方法的第二个参数可以使用美元符号 <code>$</code>，用来指代所替换的内容。</p> <ul><li><code>$&amp;</code>：匹配的子字符串。</li> <li>$`：匹配结果前面的文本。</li> <li><code>$'</code>：匹配结果后面的文本。</li> <li><code>$n</code>：匹配成功的第 n 组内容，n 是从 1 开始的自然数。</li> <li><code>$$</code>：指代美元符号 <code>$</code>。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'hello world'.replace(/(\w+)\s(\w+)/, '$2 $1')
// &quot;world hello&quot;

'abc'.replace('b', '[$`-$&amp;-$\'$$]')
// 'a[a-b-c$]c'
</code></pre></div><h5 id="第二个参数还可以是一个函数"><a href="#第二个参数还可以是一个函数" class="header-anchor">#</a> 第二个参数还可以是一个函数</h5> <p><code>replace</code> 方法的第二个参数还可以是一个函数，<strong>将每一个匹配内容替换为函数返回值</strong></p> <p>作为 <code>replace</code> 方法第二个参数的替换函数，可以接受多个参数。</p> <ul><li>第一个参数是捕捉到的内容</li> <li>第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。</li></ul> <p>此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>'6 and 10'
'3 and 5'.replace(/[0-9]+/g, function (...args) {
  console.log(args)
  return 2 * args[0];
})
//'6 and 10'
// ['3', 0, '3 and 5'] 注意倒数第二个和倒数第一个参数
// ['5', 6, '3 and 5']
</code></pre></div><h5 id="replace-应用"><a href="#replace-应用" class="header-anchor">#</a> replace 应用</h5> <ol><li>将价格插入到模板中</li></ol> <div class="language- extra-class"><pre class="language-text"><code>var prices = {
  'p1': '$1.99',
  'p2': '$9.99',
  'p3': '$5.00'
};

var template = '&lt;span id=&quot;p1&quot;&gt;&lt;/span&gt;'
  + '&lt;span id=&quot;p2&quot;&gt;&lt;/span&gt;'
  + '&lt;span id=&quot;p3&quot;&gt;&lt;/span&gt;';

template.replace(
  /(&lt;span id=&quot;)(.*?)(&quot;&gt;)(&lt;\/span&gt;)/g,
  function(match, $1, $2, $3, $4){
    return $1 + $2 + $3 + prices[$2] + $4;
  }
);
</code></pre></div><ol start="2"><li>消除字符串首尾两端的空格</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">customTrim</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 正则表达式：匹配字符串开头和结尾的空白字符</span>
  <span class="token comment">// ^\s+ 匹配字符串开头的一个或多个空白字符</span>
  <span class="token comment">// \s+$ 匹配字符串结尾的一个或多个空白字符</span>
  <span class="token keyword">const</span> regExp <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\s+|\s+$</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>

  <span class="token comment">// 使用 replace 方法和正则表达式移除字符串两端的空白字符</span>
  <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>regExp<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="string-prototype-split"><a href="#string-prototype-split" class="header-anchor">#</a> String.prototype.split()</h4> <p>字符串对象的 split 方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。</p> <div class="language- extra-class"><pre class="language-text"><code>// 非正则分隔
'a,  b,c, d'.split(',')
// [ 'a', '  b', 'c', ' d' ]

// 正则分隔，去除多余的空格
'a,  b,c, d'.split(/, */)
// [ 'a', 'b', 'c', 'd' ]

// 指定返回数组的最大成员
'a,  b,c, d'.split(/, */, 2)
[ 'a', 'b' ]
</code></pre></div><h5 id="贪婪匹配下的分割"><a href="#贪婪匹配下的分割" class="header-anchor">#</a> 贪婪匹配下的分割</h5> <div class="language- extra-class"><pre class="language-text"><code>// 例一
'aaa*a*'.split(/a*/)
// [ '', '*', '*' ]

// 例二
'aaa**a*'.split(/a*/)
// [&quot;&quot;, &quot;*&quot;, &quot;*&quot;, &quot;*&quot;]
</code></pre></div><p>上面代码的分割规则是 0 次或多次的 a，由于正则默认是贪婪匹配，所以例一的第一个分隔符是 aaa，第二个分割符是 a，将字符串分成三个部分，包含开始处的空字符串。例二的第一个分隔符是 aaa，第二个分隔符是 0 个 a（即空字符），第三个分隔符是 a，所以将字符串分成四个部分。</p> <h5 id="如果正则表达式带有括号-则括号匹配的部分也会作为数组成员返回"><a href="#如果正则表达式带有括号-则括号匹配的部分也会作为数组成员返回" class="header-anchor">#</a> 如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回</h5> <div class="language- extra-class"><pre class="language-text"><code>'aaa*a*'.split(/(a*)/)
// [ '', 'aaa', '*', 'a', '*' ]
</code></pre></div><h4 id="es6-的扩展"><a href="#es6-的扩展" class="header-anchor">#</a> ES6 的扩展</h4> <p>ES6 出现之前，字符串对象共有 4 个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。</p> <p>ES6 将这 4 个方法，在语言内部全部调用 RegExp 的实例方法，从而做到所有与正则相关的方法，全都定义在 RegExp 对象上。</p> <ul><li><code>String.prototype.match</code> 调用 <code>RegExp.prototype[Symbol.match]</code></li> <li><code>String.prototype.replace</code> 调用 <code>RegExp.prototype[Symbol.replace]</code></li> <li><code>String.prototype.search</code> 调用 <code>RegExp.prototype[Symbol.search]</code></li> <li><code>String.prototype.split</code> 调用 <code>RegExp.prototype[Symbol.split]</code></li></ul> <p>例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[0-9]+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
<span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'2022-01-02'</span>
<span class="token keyword">var</span> result <span class="token operator">=</span> re<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>match<span class="token punctuation">]</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">// [&quot;2022&quot;, &quot;01&quot;, &quot;02&quot;]</span>
</code></pre></div><h2 id="进阶概念"><a href="#进阶概念" class="header-anchor">#</a> 进阶概念</h2> <h3 id="匹配模式"><a href="#匹配模式" class="header-anchor">#</a> 匹配模式</h3> <h4 id="贪婪模式"><a href="#贪婪模式" class="header-anchor">#</a> 贪婪模式</h4> <p>正则表达式的匹配模式，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。</p> <div class="language- extra-class"><pre class="language-text"><code>var s = 'aaa';
s.match(/a+/) // [&quot;aaa&quot;]
</code></pre></div><p>上面代码中，模式是 <code>/a+/</code>，表示匹配 1 个 a 或多个 a，那么到底会匹配几个 a 呢？因为默认是贪婪模式，会一直匹配到字符 a 不出现为止，所以匹配结果是 3 个 a。</p> <h4 id="非贪婪模式"><a href="#非贪婪模式" class="header-anchor">#</a> 非贪婪模式</h4> <p>非贪婪模式又称懒惰模式，只需要在待匹配的量词字符后面跟随一个问号即可：<code>??</code>、<code>+?</code>、<code>*?</code>、<code>{1,5}?</code>，一旦条件满足，就不再往下匹配。</p> <div class="language- extra-class"><pre class="language-text"><code>var s = 'aaa';
s.match(/a+?/) // [&quot;a&quot;]
</code></pre></div><h5 id="再举一个例子"><a href="#再举一个例子" class="header-anchor">#</a> 再举一个例子</h5> <div class="language- extra-class"><pre class="language-text"><code>'aabab'.match(/a.*?b/g) // ['aab', 'ab']
</code></pre></div><p><code>a.*?b</code> 匹配最短的，以 a 开始，以 b 结束的字符串。把它应用于 aabab 的话，它会匹配 aab（第一到第三个字符）和 ab（第四到第五个字符）。</p> <p>为什么第一个匹配是 aab（第一到第三个字符）而不是 ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先匹配到的拥有最高的优先权——The match that begins earliest wins。</p> <h4 id="独占模式-js-暂不支持"><a href="#独占模式-js-暂不支持" class="header-anchor">#</a> 独占模式（JS 暂不支持）</h4> <p>独占模式需要在待匹配的量词字符后面跟随一个加号即可：<code>?+</code>、<code>++</code>、<code>*+</code>、<code>{1,5}+</code>。同贪婪模式一样，独占模式一样会匹配最长。不过在独占模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而不会回溯。</p> <h3 id="匹配顺序"><a href="#匹配顺序" class="header-anchor">#</a> 匹配顺序</h3> <p>通常情况下，正则将会从左到右地测试每个条件。</p> <h4 id="使用分枝条件时-要注意各个条件的顺序。"><a href="#使用分枝条件时-要注意各个条件的顺序。" class="header-anchor">#</a> 使用分枝条件时，要注意各个条件的顺序。</h4> <p>如果满足了某个分枝的话，就不会去再管其它的条件了。</p> <p>例如：美国邮编的规则是 5 位数字，或者用连字号间隔的 9 位数字。</p> <div class="language- extra-class"><pre class="language-text"><code>/\d{5}-\d{4}|\d{5}/ // 正确方式
/\d{5}|\d{5}-\d{4}/ // 错误方式，只会匹配5位的邮编(以及9位邮编的前5位)
</code></pre></div><h3 id="断言"><a href="#断言" class="header-anchor">#</a> 断言</h3> <p>断言（Assertion）也被称为零宽断言或环视（lookaround），它代表的是一个位置，这个位置应该满足一定的条件（断言），只有当断言为真时才会认为其之前或之后的正则匹配成功。</p> <p>它自身只进行子表达式的匹配，不占有字符，匹配到的内容不保存到最终的匹配结果。</p> <h4 id="先行断言"><a href="#先行断言" class="header-anchor">#</a> 先行断言</h4> <p>先行断言（lookahead）有时也被称作正向断言，语法是：<code>(?=exp)</code>，用于检查某个特定模式是否出现在另一个模式的后面（右边），通俗点说，在某个位置往右（往后）看是否匹配 <code>?=</code> 后面的子表达式。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token string">'abcabd'</span><span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">b(?=c)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span> <span class="token comment">// [&quot;b&quot;]</span>
</code></pre></div><p>上面代码中，匹配 b 的地方有两个，然后从这两个位置往右看是否匹配正向断言的子表达式 c，所以只有第一个 b 是真正匹配成功的。</p> <h5 id="密码强度校验-举例"><a href="#密码强度校验-举例" class="header-anchor">#</a> 密码强度校验（举例）</h5> <p>至少有一个大写字母。至少有一个小写字母。至少有一个数字。至少有 8 个字符。</p> <div class="language- extra-class"><pre class="language-text"><code>/^(?=.*[A-Z])(?=.*[a-z])(?=.*\d).{8,}$/.test('123456aA') // true
</code></pre></div><p>这是一个特殊的例子，用于检查字符串中是否至少有一个大写字母等。</p> <p><code>(?=.*[A-Z])</code>：用于检查字符串中是否存在至少一个大写字母。其中：</p> <ul><li><code>?=</code> 是先行断言的开始。</li> <li><code>.*</code> 代表任意数量的任意字符，这意味着大写字母可以出现在字符串中的任意位置。</li> <li><code>[A-Z]</code> 匹配任意一个大写字母。</li></ul> <h4 id="先行否定断言"><a href="#先行否定断言" class="header-anchor">#</a> 先行否定断言</h4> <p>先行否定断言（negative lookahead）有时也被称为正向否定断言，语法是：<code>(?!=exp)</code>，用于确保某个模式后面不跟随另一个特定的模式</p> <div class="language- extra-class"><pre class="language-text"><code>/\d+(?!\.)/.exec('3.14') // [&quot;14&quot;]
</code></pre></div><p>上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是 14。</p> <h5 id="数字格式化-举例"><a href="#数字格式化-举例" class="header-anchor">#</a> 数字格式化（举例）</h5> <p>1234567890 格式化为 1,234,567,890</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> test <span class="token operator">=</span> <span class="token string">'1234567890'</span>
<span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\B(?=(\d{3})+(?!\d))</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>主要看一下正则表达式部分：</p> <ul><li><code>\B</code> 非词边界，即在词内部的间隔处</li> <li><code>?=</code> 先行断言，后面必须匹配
<ul><li><code>(\d{3})+</code> 1 个或多个连续的三个数字</li> <li><code>?!</code> 先行否定断言，多个连续的三个数字后不能有数字</li></ul></li></ul> <h4 id="后行断言"><a href="#后行断言" class="header-anchor">#</a> 后行断言</h4> <p>后行断言（lookbehind）有时也被称为反向断言，语法是：<code>(?&lt;=exp)</code>，用于检查某个特定模式是否出现在另一个模式的前面（左边）。</p> <div class="language- extra-class"><pre class="language-text"><code>/(?&lt;=\$)\d+/.exec('123$100') // 100
</code></pre></div><p>“后行断言”的实现，需要先匹配 <code>/(?&lt;=y)x/</code> 的 <code>x</code>，然后再回到左边，匹配 <code>y</code> 的部分。这种“先右后左”的执行顺序（后行），与所有其他正则操作相反，导致了一些不符合预期的行为。</p> <h5 id="后行断言的组匹配"><a href="#后行断言的组匹配" class="header-anchor">#</a> 后行断言的组匹配</h5> <div class="language- extra-class"><pre class="language-text"><code>/^(\d+)(\d+)$/.exec('1053') // [&quot;1053&quot;, &quot;105&quot;, &quot;3&quot;]
</code></pre></div><p>没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是 105 和 3。</p> <div class="language- extra-class"><pre class="language-text"><code>/(?&lt;=(\d+)(\d+))$/.exec('1053') // [&quot;&quot;, &quot;1&quot;, &quot;053&quot;]
</code></pre></div><p>有“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是 1 和 053。</p> <h5 id="后行断言的引用字符"><a href="#后行断言的引用字符" class="header-anchor">#</a> 后行断言的引用字符</h5> <p>如果后行断言的反斜杠引用字符（<code>\1</code>）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。<strong>因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。</strong></p> <div class="language- extra-class"><pre class="language-text"><code>/(?&lt;=(o)d\1)r/.exec('hodor')  // null
/(?&lt;=\1d(o))r/.exec('hodor')  // [&quot;r&quot;, &quot;o&quot;]
</code></pre></div><h4 id="后行否定断言"><a href="#后行否定断言" class="header-anchor">#</a> 后行否定断言</h4> <p>后行否定断言（negative lookbehind）有时也被称为反向否定断言，语法是：<code>(?&lt;!exp)</code>，用于确保某个模式前面不是另一个特定的模式。</p> <div class="language- extra-class"><pre class="language-text"><code>/(?&lt;!\$)\d+/.exec('123$100') // 123
</code></pre></div><h2 id="正则表达式引擎"><a href="#正则表达式引擎" class="header-anchor">#</a> 正则表达式引擎</h2> <p>正则表达式的执行需要正则引擎，正则引擎主要分为两类：</p> <ul><li>DFA（Deterministic finite automaton） 确定型有穷自动机
<ul><li>使用 DFA 引擎的程序：awk（大多数版本）、egrep（大多数版本）、flex、lex、MySQL 等</li></ul></li> <li>NFA（Non-deterministic finite automaton）不确定型有穷自动机
<ul><li>使用 NFA 引擎的程序：Java、Perl、PCRE library、less、more、sed（大多数版本）、Python、Ruby 等</li> <li>一般指的是 Traditional NFA</li></ul></li></ul> <p>其实：NFA 还能继续分为 Traditional NFA 和 POSIX NFA，这就跟 PCRE 流派和 POSIX 流派有些关系了，另外还有一些程序支持 DFA 和 NFA 的结合体，例如 GNU awk</p> <h4 id="确定型和不确定型"><a href="#确定型和不确定型" class="header-anchor">#</a> 确定型和不确定型</h4> <p>假设有一个字符串 abc 需要匹配，在没有编写正则表达式的前提下，<strong>直接可以确定字符匹配顺序的就是确定型，不能确定字符匹配顺序的就是不确定型</strong>。</p> <h4 id="有穷"><a href="#有穷" class="header-anchor">#</a> 有穷</h4> <p>有穷即表示有限的意思，这里表示有限的次数内能得到结果</p> <h4 id="自动机"><a href="#自动机" class="header-anchor">#</a> 自动机</h4> <p>自动机就是自动完成，在我们设置好匹配规则后由引擎会自动完成，不需要人为干预。</p> <h3 id="dfa-引擎"><a href="#dfa-引擎" class="header-anchor">#</a> DFA 引擎</h3> <p>DFA 是从匹配文本入手，从左到右，每个字符不会匹配两次，它的时间复杂度是多项式的，所以通常情况下，它的速度更快，但支持的特性很少，不支持捕获组、各种引用等等</p> <p>正则里面的 DFA 引擎实际上就是把正则表达式转换成一个图的邻接表，然后通过跳表的形式判断一个字符串是否匹配该正则。</p> <h4 id="dfa-的特点"><a href="#dfa-的特点" class="header-anchor">#</a> DFA 的特点</h4> <ul><li>先看文本，再看正则，<strong>以文本为主导</strong></li> <li>匹配过程，字符串只看一次，不管正则表达式写得多烂，匹配速度都很快</li> <li>不支持捕获组、断言等高级功能</li></ul> <h3 id="nfa-引擎"><a href="#nfa-引擎" class="header-anchor">#</a> NFA 引擎</h3> <p>NFA 是从正则表达式入手，不断读入字符，尝试是否匹配当前正则，不匹配则吐出字符重新尝试，通常它的速度比较慢，最优时间复杂度为多项式的，最差情况为指数级的。但 NFA 支持更多的特性，因而绝大多数编程场景下（包括 Java，JS），就是 NFA。</p> <p>正则里面 NFA 引擎实际上就是在语法解析的时候，构造出的一个有向图。然后通过深搜的方式，去一条路径一条路径的递归尝试。</p> <h4 id="nfa-的特点"><a href="#nfa-的特点" class="header-anchor">#</a> NFA 的特点</h4> <ul><li>先看正则，再看文本，<strong>以正则为主导</strong></li> <li>匹配过程中，可能会发生回退，字符串同一部分会比较多次（通常将回退称为“回溯”）</li> <li>功能强大，可以拿到匹配的上下文信息，支持捕获组、断言等功能</li></ul> <h3 id="灾难性回溯真实案例"><a href="#灾难性回溯真实案例" class="header-anchor">#</a> 灾难性回溯真实案例</h3> <p>大部分语言的正则引擎都是 NFA 的，JS 也是，如果写出了有性能问题的正则表达式，容易造成灾难性回溯。</p> <p>使用 <a href="https://regex101.com/" target="_blank" rel="noopener noreferrer">regex101<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 统计 step</p> <div class="language- extra-class"><pre class="language-text"><code>let regexp = /^(\w+\s?)*$/;

alert( regexp.test(&quot;A good string&quot;) ); // true 一共 14 steps
alert( regexp.test(&quot;Bad characters: $@#&quot;) ); // false 一共 16412 steps，如果字符串再长一点会执行更多 step
</code></pre></div><ul><li><a href="https://zh.javascript.info/regexp-catastrophic-backtracking" target="_blank" rel="noopener noreferrer">必看-灾难性回溯<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.cnblogs.com/study-everyday/p/7426862.html" target="_blank" rel="noopener noreferrer">一个由正则表达式引发的血案<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjA1NzEwMA==&amp;mid=2651019020&amp;idx=1&amp;sn=49ea80e217d17703647ae40fff0c0369&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">觅迹寻踪之正则表达式<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h4 id="如何避免"><a href="#如何避免" class="header-anchor">#</a> 如何避免</h4> <ul><li>改用 DFA 的正则引擎（速度快，功能弱，没有捕获组断言等功能）</li> <li>提高对正则性能问题的重视，开发的时候少写模糊匹配，越精确越好，因为模糊匹配、贪婪匹配、懒惰匹配都可能带来回溯问题</li> <li>使用独占模式可以有效避免回溯问题（JS 暂时没有此模式）</li> <li>不要滥用括号和字符类</li> <li>拆分表达式，有时候，多个小正则表达式的速度比一个大正则表达式的速度要快</li></ul> <h2 id="性能"><a href="#性能" class="header-anchor">#</a> 性能</h2> <h3 id="基本概述"><a href="#基本概述" class="header-anchor">#</a> 基本概述</h3> <h4 id="正则表达式的性能高于常规的循环遍历字符串操作"><a href="#正则表达式的性能高于常规的循环遍历字符串操作" class="header-anchor">#</a> 正则表达式的性能高于常规的循环遍历字符串操作</h4> <h4 id="如果只需要匹配几个字母的大小写-可以直接写明-如果使用-i修饰符-会每个字母都匹配一遍大小写"><a href="#如果只需要匹配几个字母的大小写-可以直接写明-如果使用-i修饰符-会每个字母都匹配一遍大小写" class="header-anchor">#</a> 如果只需要匹配几个字母的大小写，可以直接写明，如果使用 <code>i</code>修饰符，会每个字母都匹配一遍大小写</h4> <div class="language- extra-class"><pre class="language-text"><code>/[MmSs]/.test('mS')
</code></pre></div><h4 id="尽量使用正则表达式字面量形式"><a href="#尽量使用正则表达式字面量形式" class="header-anchor">#</a> 尽量使用正则表达式字面量形式</h4> <p>因为 JavaScript 引擎会在脚本加载时编译正则表达式字面量。相比之下，使用 <code>RegExp</code> 构造函数创建的正则表达式可能会在每次使用时都重新编译</p> <h4 id="使用行或者字符串的开始、结束符"><a href="#使用行或者字符串的开始、结束符" class="header-anchor">#</a> 使用行或者字符串的开始、结束符</h4> <p>如果是从行首或者行尾匹配，使用 <code>^</code> 或 <code>$</code> 能更精准匹配</p> <h2 id="扩展"><a href="#扩展" class="header-anchor">#</a> 扩展</h2> <h3 id="匹配中文字符"><a href="#匹配中文字符" class="header-anchor">#</a> 匹配中文字符</h3> <ul><li><code>[\u4e00-\u9fa5]</code> 是错的，不要用二十年前的正则表达式了</li> <li><code>/\p{Unified_Ideograph}/u</code> 是正确的，不需要维护，匹配所有汉字。这里 <code>\p</code> 是 Unicode 属性转义正则表达式，并且需要使用 <code>u</code> 修饰符。</li> <li><code>/\p{Ideographic}/u</code> 和 <code>/\p{Script=Han}/u</code> 匹配除了汉字以外的其他一些字符，太宽泛，在「汉字匹配正则表达式」这个需求下，是错的。</li> <li>目前只有 Chrome 支持 Unicode 属性转义正则表达式。对其他环境，使用 @babel/plugin-proposal-unicode-property-regex 和 regexpu-core 进行优雅降级。</li></ul> <p>具体细节可以看</p> <ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNTAzMjcxNg%3D%3D&amp;mid=2651425175&amp;idx=1&amp;sn=87dfcb5cee723f8a2997f2376f8f17e1#wechat_redirect" target="_blank" rel="noopener noreferrer">JavaScript 正则表达式匹配汉字<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.bookstack.cn/read/zh.javascript.info/49063ecacf52dcca.md" target="_blank" rel="noopener noreferrer">Unicode：修饰符 “u” 和 class \p{…}<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="链接"><a href="#链接" class="header-anchor">#</a> 链接</h2> <h3 id="技术文章"><a href="#技术文章" class="header-anchor">#</a> 技术文章</h3> <ul><li><a href="https://mp.weixin.qq.com/s/hYYDRHgjBs0TVTQty9pSBw" target="_blank" rel="noopener noreferrer">梳理正则表达式发展史<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://wangdoc.com/javascript/stdlib/regexp" target="_blank" rel="noopener noreferrer">RegExp 对象<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.bookstack.cn/read/zh.javascript.info/bf6e57fcc0ce32fb.md" target="_blank" rel="noopener noreferrer">现代 JavaScript 教程中文版-正则表达式<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://segmentfault.com/a/1190000021787021" target="_blank" rel="noopener noreferrer">正则表达式引擎执行原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://www.alloyteam.com/2019/07/13574/" target="_blank" rel="noopener noreferrer">浅谈正则表达式原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="验证和联系"><a href="#验证和联系" class="header-anchor">#</a> 验证和联系</h3> <ul><li><a href="https://regex101.com/" target="_blank" rel="noopener noreferrer">regex101<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://jex.im/regulex/#!flags=&amp;re=%5E(a%7Cb)*%3F%24" target="_blank" rel="noopener noreferrer">JavaScript Regular Expression Visualizer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://regexone.com/" target="_blank" rel="noopener noreferrer">正则练习 RegexOne - Learn Regular Expressions<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://any86.github.io/any-rule/" target="_blank" rel="noopener noreferrer">正则大全<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/francisrstokes/super-expressive" target="_blank" rel="noopener noreferrer">super-expressive 用自然语言的方式构建正则表达式<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/qiqihaobenben/Front-End-Basics/edit/master/docs/javascript/utility/regexp.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2/2/2024, 7:43:00 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f0c3bf6e.js" defer></script><script src="/assets/js/2.267df354.js" defer></script><script src="/assets/js/1.66cc43cf.js" defer></script><script src="/assets/js/214.42974ae8.js" defer></script>
  </body>
</html>
